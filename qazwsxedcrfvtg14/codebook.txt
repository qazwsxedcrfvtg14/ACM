//bit binary indexed tree  //index 1~n
void insert(int a,int val){
    while(a<=n){
        bit[a]+=val;
        a+=a&-a;
        }
}
int sum(int a){          //query sum [1,a]
    int ans=0;
    while(a){
        ans+=bit[a];
        a-=a&-a;
        }
    return ans;
}

//線段樹
int max(int a,int b){return a>b?a:b;}
void mkt(int idx,int L,int R){
    if(L==R){tree[idx]=ar[L];return;}
    int mid=L+R>>1,lidx=idx*2+1;
    mkt(lidx,L,mid);
    mkt(lidx+1,mid+1,R);
    tree[idx]=max(tree[lidx],tree[lidx+1]);
}
int qry(int idx,int L,int R,int x,int y){
    if(y<L||x>R)return -100000;
    if(L>=x&&R<=y)return tree[idx];
    int mid=L+R>>1,lidx=idx*2+1;
    return max(qry(lidx,L,mid,x,y),qry(lidx+1,mid+1,R,x,y));
}
mkt(0,0,n-1);
scanf("%d",&m);
while(m--){
    int i,j;
    scanf("%d%d",&i,&j);
    if(i>j){int l=i;i=j;j=l;}
    printf("%d\n",qry(0,0,n-1,i-1,j-1));
    }

//Static RMQ 
void make(int n){            //區間最大最小值
    for(int i=0; i<n;i++)
        v1[0][i]=ar[i],v2[0][i]=ar[i];
    for(int i=1;(1<<i)<=n;i++)
        for(int j=0;j+(1<<i)<=n;j++)
            v1[i][j]=min(v1[i-1][j],v1[i-1][j+(1<<(i-1))]),v2[i][j]=max(v2[i-1][j],v2[i-1][j+(1<<(i-1))]);
    return;
    }
unsigned int qry(int a,int b){  //查詢區間最大最小值
    int p = 31 - __builtin_clz(abs(b-a)+1);
    return max(v2[p][a],v2[p][b-(1<<p)+1])-min(v1[p][a],v1[p][b-(1<<p)+1]);
    }

//畢氏數特性：
(m,n)=1
m^2-n^2, 2mn, m^2+n^2

//最大公因數
int gcd(int a,int b){
    int c;
    while(b!=0){
        a%=b;
        c=a;a=b;b=c;
        }
    return a;
    }

//模逆元
long long int inverse(long long int a, long long int m){ 
    long long int d = m, x = 0, s = 1, q, r, t;
    while(a!=0){
        q=d/a,r=d%a;
        d=a,a=r;
        t=x-q*s,x=s,s=t;
        }
    if(d!=1)return -1;  // 沒有倒數、無法整除
    return(x+m)%m;
    }	

//擴展歐基理德
//ax+by==gcd(a,b)的解
LL ext_gcd (LL a, LL b, LL &x, LL &y) {
    LL ret=a;
    if(b)ret=ext_gcd(b,a%b,y,x),y-=(a/b)*x;
    else x=1,y=0;
    return ret;
    }
//中國剩餘定理 slove X=r mod m;
LL ex_crt(LL *m,LL *r,int n){
    LL M=m[0],R=r[0],x,y,d;
    for (int i=1;i<n;i++){
        d=ex_gcd(M,m[i],x,y);
        if((r[i]-R)%d)return -1;
        x=(r[i]-R)/d*x%(m[i]/d);
        R+=x*M;
        M=M/d*m[i];
        R%=M;
        }
    return R>0?R:R+M;
    }


//模逆元
LL modInv (LL a, LL m) {
    LL x, y;
    extGcd(a,m,x,y);
    return (m+x%m)%m;
}//if m为质数 [费马小定理]a^(m-1)=1 mod m ==>a^(m-2)是a关于m的逆元

//大數(可處理負數)
const int N=1000;
struct Bnum{
    char num[N+1];
    bool operator>(Bnum &B2){
        for(int i=N;i>=0;i--)
            if(num[i]<B2.num[i]){return 0;}
            else if(num[i]>B2.num[i])return 1;
        return 0;
        }
    bool operator<(Bnum &B2){
        for(int i=N;i>=0;i--)
            if(num[i]>B2.num[i])return 0;
            else if(num[i]<B2.num[i])return 1;
        return 0;
        }
    bool operator==(Bnum &B2){
        for(int i=0;i<=N;i++)
            if(num[i]!=B2.num[i])return 0;
        return 1;
        }
    bool operator!=(Bnum &B2){
        return !operator==(B2);
        }
    void operator=(Bnum B2){
        for(int i=0;i<=N;i++)
            num[i]=B2.num[i];
        }
    void operator=(int a){
        (*this).clear();
        for(int i=0;i<=N;i++){
            num[i]=a%10;
            a/=10;
            if(!a)break;
            }
        }
    void operator+=(Bnum &B2){
        for(int i=0;i<=N;i++)
            num[i]+=B2.num[i];
        for(int i=0;i<N;i++)
            if(num[i]>=10){num[i]-=10;num[i+1]++;}
        }
    void operator-=(Bnum &B2){
        for(int i=0;i<=N;i++)
            num[i]-=B2.num[i];
        for(int i=0;i<N;i++)
            if(num[i]<0){num[i]+=10;num[i+1]--;}
        }
    void operator*=(Bnum B2){
        Bnum B3;
        if(num[N]<0||B2.num[N]<0){
            int bol=0;
            Bnum B4,B5;
            B4.clear();
            if(B2.num[N]<0)B4-=B2,bol++;
            else B4=B2;
            if(num[N]<0){bol++;
                for(int i=0;i<=N;i++)
                    B5.num[i]=-num[i];
                for(int i=0;i<N;i++)
                    if(B5.num[i]<0){B5.num[i]+=10;B5.num[i+1]--;}
                }
            else{
                for(int i=0;i<=N;i++)
                    B5.num[i]=num[i];
                }
            B4*=B5;
            if(bol%2){
                for(int i=0;i<=N;i++)
                    num[i]=-B4.num[i];
                for(int i=0;i<N;i++)
                    if(num[i]<0){num[i]+=10;num[i+1]--;}
                return;
                }
            for(int i=0;i<=N;i++)
                num[i]=B4.num[i];
            return;
            }
        for(int i=0;i<=N;i++)
            B3.num[i]=num[i],num[i]=0;
        for(int i=0;i<(N>>1);i++)
            for(int j=0;j<(N>>1);j++){
                num[i+j]+=B2.num[i]*B3.num[j];
                if(num[i+j]>=10){num[i+j+1]+=num[i+j]/10;num[i+j]%=10;}
                }
        for(int i=0;i<N;i++)
            if(num[i]>=10){num[i+1]+=num[i]/10;num[i]%=10;}
        }
    void operator<<=(int a){
        for(int i=N;i>=a;i--)
            num[i]=num[i-a];
        for(int i=0;i<a;i++)
            num[i]=0;
        }
    void operator>>=(int a){
        for(int i=0;i<=N-a;i++)
            num[i]=num[i+a];
        for(int i=N-a+1;i<=N;i++)
            num[i]=0;
        }
    Bnum operator/(Bnum &B2){
        Bnum k,ans,t,zero,tmp;
        zero.clear();
        t=1;
        k=B2;
        tmp=(*this);
        ans.clear();
        while(k<(*this)||k==(*this)){
            k<<=1;
            t<<=1;
            }
        k>>=1;
        t>>=1;
        while(t!=zero){
            while(tmp>k||tmp==k){
                tmp-=k;
                ans+=t;
                }
            t>>=1;
            k>>=1;
            }
        return ans;
        }
    void clear(){
        for(int i=0;i<=N;i++)
            num[i]=0;
        }
    void print(){
        bool zero=0,rem=0;
        char output[N+10];
        int place;
        Bnum tmp;
        if(num[N]<0){
            for(int i=0;i<=N;i++)
                tmp.num[i]=num[i];
            for(int i=0;i<=N;i++)
                num[i]=-num[i];
            for(int i=0;i<N;i++)
                if(num[i]<0){num[i]+=10;num[i+1]--;}
            rem=1;
            }
        int op=0;
        for(int i=N-1;i>=0;i--){
            if(zero==1){
                output[op++]=num[i]+'0';
                }
            else if(num[i]!=0){
                output[op++]=num[i]+'0';
                zero=1;
                }
            }
        output[op++]=0;
        if(zero==0)printf("0");
        else if(rem){
            putchar('-');
            printf(output);
            for(int i=0;i<=N;i++)
                num[i]=tmp.num[i];
            }
        else{
            printf(output);
            }
        }
    bool scan(){
        char input[N];
        int tmp=0;
        if(!(~scanf("%s",input)))return 0;
        if(input[0]=='-'){tmp=1;}
        int len=strlen(input);
        for(int i=0;i<=N;i++)
            num[i]=0;
        for(int i=tmp;i<len;i++)
            num[i-tmp]=input[len-(i-tmp)-1]-'0';
        if(tmp){
            for(int i=0;i<=N;i++)
                num[i]=-num[i];
            for(int i=0;i<N;i++)
                if(num[i]<0){num[i]+=10;num[i+1]--;}
            }
        return 1;
        }
    };

int main(){
    string s;
    while(cin>>s){
        sort(s.begin(),s.end());
        do{
            printf("%s\n",&s[0]);
            }while(next_permutation(s.begin(),s.end()));
        }
    return 0;
    }

//__builtin
* int __builtin_ffs (unsigned int x)
      返回x的最後一位1的是從後向前第幾位，比如7368（1110011001000）返回4。
* int __builtin_clz (unsigned int x)
      返回前導的0的個數。
* int __builtin_ctz (unsigned int x)
      返回後面的0個個數，和__builtin_clz相對。
* int __builtin_popcount (unsigned int x)
      返回二進製表示中1的個數。
* int __builtin_parity (unsigned int x)
      返回x的奇偶校驗位，也就是x的1的個數模2的結果。
p.s.在函數名稱後面加ll就可以用在long long int 上了。
31 - __builtin_clz(a)   取log2(a)==__lg(a)

//靜態區間最大值
const int N = 1000;
const int logN = ceil(log2(N));
int value[N];
int t[logN][N]; // t[i][j]儲存區間[j, j+(2^i)-1]的最小值的索引值
void construct(){
    for (int i=0; i<N; ++i)
        t[0][i] = value[i];
    for (int i=1; (1<<i)<=N; ++i)
        for (int j=0; j+(1<<i)<=N; ++j)
            t[i][j] = min(t[i-1][j], t[i-1][j+(1<<(i-1))]);
}
int query(int a, int b){
    int p = 31 - __builtin_clz(abs(b - a) + 1);
    return min(t[p][a], t[p][b-(1<<p)+1]);
}

//KMP
    while(~scanf("%s",s)){
        int len=strlen(s);
        for(int i=0;i<len;i++){
            ss[len-i-1]=s[i];
            }
        ss[len]=0;
        dp[0]=-1;
        for(int i=1;i<len;i++){
            int p=dp[i-1];
            while(p!=-1&&ss[p+1]!=ss[i]){
                p=dp[p];
            }
            if(ss[p+1]!=ss[i])dp[i]=-1;
            else
                dp[i]=p+1;
        }
        int p=0;
        for(int i=0;i<len;i++){
            if(s[i]==ss[p]){
                p++;
                }
            else{
                if(p!=0){
                    p=dp[p-1]+1;
                    i--;
                    }
                }
            }
        printf("%s%s ",s,ss+p);
        }

//SA+H
const int N=100005;
char s[N];
int n,SA[N],rk[2][N];
void mak_SA(){
    int n=strlen(s)+1;
    for(int i=0;i<n;i++)
        rk[0][i]=s[i],SA[i]=i;
    for(int k=0;(1<<k)<n;k++){
        int pri=k&1,now=~k&1;
        sort(SA,SA+n,[&pri,&k](int a,int b){
            if(rk[pri][a]==rk[pri][b])return rk[pri][a+(1<<k)]<rk[pri][b+(1<<k)];
            return rk[pri][a]<rk[pri][b];
            });
        int cnt=0;
        rk[now][SA[0]]=cnt;
        for(int i=1;i<n;i++){
            cnt+=(rk[pri][SA[i-1]]!=rk[pri][SA[i]]) || (rk[pri][SA[i-1]+(1<<k)]!=rk[pri][SA[i]+(1<<k)]);
            rk[now][SA[i]]=cnt;
            }
        if(cnt==n)return;
        }
    }
int SA[N],buk[N],rk1[N],rk2[N]; 
void mak_SA2(){//buggy
    int n=strlen(s)+1;
    int *rnk=rk1,*rp=rk2;
    for(int i=0;i<n;i++)
        rp[i]=s[i];
    sort(rp,rp+n);
    int m=unique(rp,rp+n)-rp;
    for(int i=0;i<m;i++)buk[i]=0;
    for(int i=0;i<n;i++)buk[rnk[i]=lower_bound(rp,rp+m,s[i])-rp]++;
    for(int i=1;i<m;i++)buk[i]+=buk[i-1];
    for(int i=n-1;i>=0;i--)SA[--buk[rnk[i]]]=i;
    int p=m;
    for(int j=1;p<n;j*=2,m=p){
        p=0;
        for(int i=n-j;i<n;i++)rp[p++]=i;
        for(int i=0;i<n;i++)if(SA[i]>=j)rp[p++]=SA[i]-j;
        for(int i=0;i<m;i++)buk[i]=0;
        for(int i=0;i<n;i++)buk[rnk[rp[i]]]++;
        for(int i=1;i<m;i++)buk[i]+=buk[i-1];
        for(int i=n-1;i>=0;i--)SA[--buk[rnk[rp[i]]]]=rp[i];
        swap(rnk,rp);
        p=1;
        rnk[SA[0]]=0;
        for(int i=1;i<n;i++)
            rnk[SA[i]]=(rp[SA[i]]==rp[SA[i-1]]&&rp[SA[i]+j]==rp[SA[i-1]+j])?p-1:p++;
        }
    n--; 
    for(int i=0;i<n;i++)
        SA[i]=SA[i+1]; 
    }
int rnk[N];   // 各個後綴對應的名次
int H[N];   // longest common prefix array
void mak_H(){
    // 也就是各個後綴在sa當中的索引值
    // 也就是sa的反函數
    for(int i=0;i<n;i++)
        rnk[SA[i]]=i;
    for (int i=0,lcp=0;i<n;i++)
        if(rnk[i]==0)
            H[0]=0;
        else{
            int j=SA[rnk[i]-1];
            if(lcp>0)lcp--;
            while(s[i+lcp]==s[j+lcp])lcp++;
            H[rnk[i]]=lcp;
            }
    }

//Suﬃx Array (SAIS TWT514)
struct SA{
    #define REP(i,n) for ( int i=0; i<int(n); i++ )
    #define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )
    static const int MXN = 300010;
    bool _t[MXN*2];
    int _s[MXN*2], _sa[MXN*2], _c[MXN*2], x[MXN], _p[ MXN], _q[MXN*2], hei[MXN], r[MXN];
    int operator [] (int i){ return _sa[i]; }
    void build(int *s, int n, int m){
        memcpy(_s, s, sizeof(int) * n);
        sais(_s, _sa, _p, _q, _t, _c, n, m);
        mkhei(n);
        }
    void mkhei(int n){
        REP(i,n) r[_sa[i]] = i;
        hei[0] = 0;
        REP(i,n) if(r[i]) {
            int ans = i>0 ? max(hei[r[i-1]] - 1, 0) : 0;
            while(_s[i+ans] == _s[_sa[r[i]-1]+ans]) ans++;
            hei[r[i]] = ans;
            }
        }
    void sais(int *s, int *sa, int *p, int *q, bool *t, int *c, int n, int z){
        bool uniq = t[n-1] = true, neq;
        int nn = 0, nmxz = -1, *nsa = sa + n, *ns = s + n, lst = -1;
#define MS0(x,n) memset((x),0,n*sizeof(*(x)))
#define MAGIC(XD) MS0(sa, n); \
        memcpy(x, c, sizeof(int) * z); \
        XD; \
        memcpy(x + 1, c, sizeof(int) * (z - 1)); \
        REP(i,n) if(sa[i] && !t[sa[i]-1]) sa[x[s[sa[i ]-1]]++] = sa[i]-1; \
        memcpy(x, c, sizeof(int) * z); \
        for(int i = n - 1; i >= 0; i--) if(sa[i] && t[ sa[i]-1]) sa[--x[s[sa[i]-1]]] = sa[i]-1;
        MS0(c, z);
        REP(i,n) uniq &= ++c[s[i]] < 2;
        REP(i,z-1) c[i+1] += c[i];
        if (uniq) { REP(i,n) sa[--c[s[i]]] = i; return; }
        for(int i = n - 2; i >= 0; i--)
            t[i] = (s[i]==s [i+1] ? t[i+1] : s[i]<s[i+1]);
        MAGIC(REP1(i,1,n-1)
        if(t[i] && !t[i-1])
            sa[--x[ s[i]]]=p[q[i]=nn++]=i);
        REP(i, n) if (sa[i] && t[sa[i]] && !t[sa[i]-1]) {
            neq=lst<0||memcmp(s+sa[i],s+lst,(p[q[sa[i ]]+1]-sa[i])*sizeof(int));
            ns[q[lst=sa[i]]]=nmxz+=neq;
            }
        sais(ns, nsa, p + nn, q + n, t + n, c + z, nn, nmxz + 1);
        MAGIC(for(int i = nn - 1; i >= 0; i--) sa[--x[s [p[nsa[i]]]]] = p[nsa[i]]);
        }
    }sa;

int _hei[200001], _sa[200001];

void suffix_array(int* ip, int len) {
    // should padding a zero in the back
    // s is int array, n is array length
    // s[0..n-1] != 0, and s[n] = 0
    // resulting SA will be length n+1
    ip[len++] = 0; sa.build(ip, len, 128);
    // original 1-base
    for (int i=0; i<len; i++) {
        _hei[i] = sa.hei[i + 1];
        _sa[i] = sa._sa[i + 1];
        }
    }

//Treap
struct node;
struct nil_node_arg{};
typedef struct node* ptr;
extern node nil_obj;
ptr nil=&nil_obj;
struct node{
    ptr l,r,fa;
    int v;
    unsigned int sz;
    node(int _v,ptr _fa=nil){v=_v,sz=1,l=r=nil,fa=_fa;}
    node(nil_node_arg*){v=0,sz=0,fa=l=r=nil;}
    inline void push(){fa=nil;}
    inline void pull(){sz=l->sz+r->sz+1;if(l!=nil)l->fa=this;if(r!=nil)r->fa=this;}
    }nil_obj(new nil_node_arg());
ptr merge(ptr a,ptr b){
    static unsigned int S=rand();
    if(a==nil)return b;if(b==nil)return a;
    if((S++)%(a->sz+b->sz)<a->sz){a->push(),a->r=merge(a->r,b),a->pull();return a;}
    else{b->push(),b->l=merge(a,b->l),b->pull();return b;}
    }
void split(ptr now,int k,ptr &a,ptr &b){
    if(now==nil)a=b=nil;
    else if(now->v<k)
        a=now,a->push(),split(now->r,k,a->r,b),a->pull();
    else
        b=now,b->push(),split(now->l,k,a,b->l),b->pull();
    }
void split_kth(ptr now,int k,ptr &a,ptr &b){
    if(now==nil)a=b=nil;
    else if(now->l->sz<k)
        a=now,a->push(),split_kth(now->r,k-now->l->sz,a->r,b),a->pull();
    else
        b=now,b->push(),split_kth(now->l,k,a,b->l),b->pull();
    }
struct treap{
    ptr root;
    treap(){root=nil;}
    void insert(int k){
        ptr a=nil,b=nil;
        split(root,k,a,b);
        root=merge(merge(a,new node(k)),b);
        }
    void erase(int k){
        ptr a=nil,b=nil,c=nil,d=nil;
        split(root,k,a,b);
        split_kth(b,1,c,d);
        if(c!=nil)
            delete c;
        root=merge(a,d);
        }
    void push_back(int k){
        root=merge(root,new node(k));
        }
    void pop_back(int k){
        ptr a=nil,b=nil;
        if(root->sz)return;
        split_kth(root,root->sz-1,a,b);
        delete b;
        root=a;
        }
    ptr kth(ptr rot,unsigned int k){//0base
        if(k<rot->l->sz)return kth(rot->l,k);
        if(k==rot->l->sz)return rot;
        return kth(rot->r,k-rot->l->sz-1);
        }
    ptr operator[](unsigned int k){
        if(k>=root->sz)return nil;
        return kth(root,k);
        }
    ptr lower_bound(int k){
        ptr now=root,pri=nil;
        while(now!=nil)
            if(k<=now->v)pri=now,now=now->l;
            else now=now->r;
        return pri;
        }
    ptr upper_bound(int k){
        ptr now=root,pri=nil;
        while(now!=nil)
            if(k<now->v)pri=now,now=now->r;
            else now=now->l;
        return pri;
        }
    };

//二分圖匹配 //可用Dinic，時間複雜度更低O(EsqrtV)
bool mp[1005][1005];
int go[1005];
bool used[1005];
int main(){
    int n,k,T=0;
    while(~scanf("%d%d",&n,&k),n||k){T++;
        memset(mp,0,sizeof(mp));
        for(int i=0;i<k;i++){
            int x,y;
            scanf("%d%d",&x,&y);
            mp[x-1][y-1]=1;
            }
        memset(go,-1,sizeof(go));
        int ans=0;
        for(int i=0;i<n;i++){
            memset(used,0,sizeof(used));
            function<bool(int)>F=[&](int now)->bool{
                for(int j=0;j<n;j++)
                    if(mp[now][j] && !used[j]++ && (!~go[j]||F(go[j])) ){
                        go[j]=now;
                        return 1;
                        }
                return 0;
                };
            ans+=F(i);
            }
        printf("Case #%d:%d\n",T,ans);
        }
    return 0;
    }

//一般圖最大匹配
#define MAXN 505
vector<int>g[MAXN];//用vector存圖 
int pa[MAXN],match[MAXN],st[MAXN],S[MAXN],vis[MAXN];
int t,n;
int lca(int u,int v){//找花的花托 
	for(++t;;swap(u,v)){
		if(u==0)continue;
		if(vis[u]==t)return u;
		vis[u]=t;//這種方法可以不用清空vis陣列 
		u=st[pa[match[u]]];
	    }
    }
#define qpush(u) q.push(u),S[u]=0
void flower(int u,int v,int l,queue<int> &q){
	while(st[u]!=l){
		pa[u]=v;//所有未匹配邊的pa都是雙向的 
		if(S[v=match[u]]==1)qpush(v);//所有奇點變偶點 
		st[u]=st[v]=l,u=pa[v];
	    }
    }
bool bfs(int u){
	for(int i=1;i<=n;++i)st[i]=i;//st[i]表示第i個點的集合 
	memset(S+1,-1,sizeof(int)*n);//-1:沒走過 0:偶點 1:奇點 
	queue<int>q;qpush(u);
	while(q.size()){
		u=q.front(),q.pop();
		for(size_t i=0;i<g[u].size();++i){
			int v=g[u][i];
			if(S[v]==-1){
				pa[v]=u,S[v]=1;
				if(!match[v]){//有增廣路直接擴充 
					for(int lst;u;v=lst,u=pa[v])
						lst=match[u],match[u]=v,match[v]=u;
					return 1;
				    }
				qpush(match[v]);
			    }
            else if(!S[v]&&st[v]!=st[u]){
				int l=lca(st[v],st[u]);//遇到花，做花的處理 
				flower(v,u,l,q),flower(u,v,l,q);
			    }
		    }
	    }
	return 0;
    }
int blossom(){
	memset(pa+1,0,sizeof(int)*n);
	memset(match+1,0,sizeof(int)*n);
    t=0;
	int ans=0;
	for(int i=1;i<=n;++i)
		if(!match[i]&&bfs(i))++ans;
	return ans;
    }

//矩陣運算套裝
template<unsigned int N,typename T=int>
struct cub{
    T a[N][N];
    int n,m; 
    cub(int _n,int _m,T k=0){
        n=_n;
        m=_m;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                a[i][j]=0;
        if(k)
            for(int i=0;i<n;i++)
                a[i][i]=k;
        }
    cub(T k=0){
        n=N;
        m=N;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                a[i][j]=0;
        if(k)
            for(int i=0;i<n;i++)
                a[i][i]=k;
        }
    void rebuild(int _n=0,int _m=0,T k=0){
        n=_n;
        m=_m;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                a[i][j]=0;
        if(k)
            for(int i=0;i<n;i++)
                a[i][i]=k;
        }
    inline T* operator [](int x){
        return a[x];
        }
    cub operator +(cub b){
        if(n!=b.n||m!=b.m)throw("+ error");
        cub c(n,m);
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                c[i][j]=a[i][j]+b[i][j];
        return c;
        }
    cub operator -(cub b){
        if(n!=b.n||m!=b.m)throw("- error");
        cub c(n,m);
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                c[i][j]=a[i][j]-b[i][j];
        return c;
        }
    cub operator *(cub b){
        if(m!=b.n)throw("* error");
        cub c(n,b.m);
        for(int i=0;i<n;i++)
            for(int j=0;j<b.m;j++)
                for(int k=0;k<m;k++)
                    c[i][j]+=a[i][k]*b[k][j];
        return c;
        }
    cub operator *(T b){
        cub c(n,m);
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                c[i][j]=a[i][j]*b;
        return c;
        }
    cub del(int x,int y){
        if(x<0||y<0||x>=n||y>=m)throw("del error");
        cub c(n-1,m-1);
        for(int i=0,ci=0;i<n;i++,ci++){
            if(i==x){ci--;continue;}
            for(int j=0,cj=0;j<m;j++,cj++){
                if(j==y){cj--;continue;}
                c[ci][cj]=a[i][j];
                }
            }
        return c;
        }
    T det(){
        if(n!=m)throw("det error");
        if(n==1)return a[0][0];
        if(n==2)return a[0][0]*a[1][1]-a[0][1]*a[1][0];
        T ret=0;
        int t=1;
        for(int i=0;i<n;i++){
            ret+=t*a[0][i]*del(0,i).det();
            t=-t;
            }
        return ret;
        }
    cub gus(){
        if(n>m)throw("gus error");
        cub mtx=*this; 
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++)
                if(mtx[j][i].p){
                    for(int k=0;k<m;k++)
                        swap(mtx[i][k],mtx[j][k]);
                    break;
                    }
            if(!mtx[i][i].p)continue;
            for(int k=n;k>=i;k--)
                mtx[i][k]=mtx[i][k]/mtx[i][i];
            for(int j=i+1;j<n;j++)
                for(int k=m-1;k>=i;k--)
                    mtx[j][k]=mtx[j][k]-mtx[i][k]*mtx[j][i];
            }
        for(int i=n-1;i>=0;i--){
            for(int j=i-1;j>=0;j--){
                for(int k=n;k<m;k++)
                    mtx[j][k]=mtx[j][k]-mtx[i][k]*mtx[j][i];
                mtx[j][i]=0;
                }
            }
        return mtx;
        }
    cub Tr(){
        cub c(m,n);
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                c[j][i]=a[i][j];
                }
            }
        return c;
        }
    cub operator -(){
        if(!det())throw("~ error");
        cub d(n,n);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                d[i][j]=del(j,i).det()*(((i+j)&1)?-1:1);
                }
            }
        return d;
        }
    cub operator ~(){
        return (-*this)*(1.0/det());
        }
    cub operator /(cub b){
        return (*this*(-b));//*b.det();
        }
    cub operator %(cub b){
        return ((-*this)*b);//*det();
        }
    cub operator ^(long long int b){
        cub ret(n,m,1),now=*this;
        while(b){
            if(b&1)ret=ret*now;
            now=now*now;
            b>>=1;
            }
        return ret;
        }
    void print(){
        printf("[ ");
        for(int i=0;i<n;i++){
            if(i)printf("; ");
            for(int j=0;j<m;j++)
                printf("%d ",a[i][j]);
            }
        printf("]\n");
        }
    };

//有理數套裝
struct lnum{
    long long int p,q;
    lnum(){q=1;p=0;}
    lnum(long long int x){q=1;p=x;}
    lnum(long long int _p,long long int _q){q=_q;p=_p;}
    void print(){
        long long int g=__gcd(p,q);
        if(!g)g=1;
        p/=g,q/=g;
        if(q<0)q*=-1,p*=-1;
        if(q==1||p==0)
            printf("%lld",p);
        else
            printf("%lld/%lld",p,q);
        }
    lnum operator=(int x){q=1;p=x;}
    lnum operator+(lnum b){
        long long int g=__gcd(q,b.q);
        return lnum(p*b.q/g+b.p*q/g,q*b.q/g);
        }
    lnum operator-(lnum b){
        long long int g=__gcd(q,b.q);
        return lnum(p*b.q/g-b.p*q/g,q*b.q/g);
        }
    lnum operator*(lnum b){
        long long int g=__gcd(p*b.p,q*b.q);
        if(!g)g=1;
        if(p==0||b.p==0)return lnum(0,1);
        return lnum(p*b.p/g,q*b.q/g);
        }
    lnum operator/(lnum b){
        return (*this)*lnum(b.q,b.p);
        }
    };

//KM
int mp[605][605],go[605],lx[605],ly[605],sl[605];
bool usx[605],usy[605];
int n;
bool F(int now,bool adj=true){
    if(usx[now])return 0;
    usx[now]=1;
    for(int i=0;i<n;i++){
        if(usy[i])continue;
        int v=lx[now]+ly[i]-mp[now][i];
        if(v)sl[i]=min(sl[i],v);
        else{
            usy[i]=1;
            if((!~go[i])||F(go[i],adj)){
                if(adj)go[i]=now;
                return 1;
                }
            }
        }
    return 0;
    };
int main(){
    while(~scanf("%d",&n)){
        memset(go,-1,sizeof(go));
        memset(ly,0,sizeof(ly));
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                scanf("%d",&mp[i][j]);
        for(int i=0;i<n;i++){
            lx[i]=-0x7fffffff;
            for(int j=0;j<n;j++)
                lx[i]=max(lx[i],mp[i][j]);
            }
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++)
                sl[j]=0x7fffffff;
            memset(usx,0,sizeof(usx));
            memset(usy,0,sizeof(usy));
            if(F(i))continue;
            bool flag=true;
            while(flag){
                int d=0x7fffffff;
                for(int j=0;j<n;j++)
                    if(!usy[j])
                        d=min(d,sl[j]);
                for(int j=0;j<n;j++){
                    if(usx[j])lx[j]-=d;
                    if(usy[j])ly[j]+=d;
                    else sl[j]-=d;
                    }
                for(int j=0;j<n;j++){
                    if(!usy[j]&&!sl[j]){
                        usy[j]=1;
                        if((!~go[j])||F(go[j],0)){
                            flag=0;
                            break;
                            }
                        }
                    }
                }
            memset(usx,0,sizeof(usx));
            memset(usy,0,sizeof(usy));
            F(i);
            }
        int ans=0;
        for(int i=0;i<n;i++)
            ans+=mp[go[i]][i];
        printf("%d\n",ans);
        }
    return 0;
    }


//引用技數指針(待驗證)
struct nod;
struct ptr{
    nod *p;
    ptr(nod *t=0);
    ptr(const ptr &t);
    ~ptr();
    ptr& operator=(const ptr &t);
    ptr& operator=(nod *t);
    nod* operator->(){return p;}
    bool operator==(const ptr &t){return p==t.p;}
    }nil;
struct nod{
    int cnt=0;
    ptr l,r;
    char v;
    int sz;
    nod():v(0),l(nil),r(nil),sz(0){cnt=0x7fffffff;}
    nod(char _v):v(_v),l(nil),r(nil),sz(1){}
    nod(ptr &nd):v(nd->v),l(nd->l),r(nd->r),sz(nd->sz){}
    void update(){sz&&(sz=1+l->sz+r->sz);}
    };
ptr::ptr(nod*t):p(t){p&&p->cnt++;}
ptr::ptr(const ptr&t):p(t.p){p&&p->cnt++;}
ptr::~ptr(){if(p&&!--p->cnt)delete p;}
ptr& ptr::operator = (const ptr &t){
    if(p&&!--p->cnt)
        delete p;
    p=t.p;
    p&&p->cnt++;
    return*this;
    }
ptr& ptr::operator = (nod *t){
    if(p&&!--p->cnt)
        delete p;
    p=t;
    p&&p->cnt++;
    return*this;
    }

//引用計數指針2(待驗證)
template<typename T>
class ptr{
    private:
        int *cnt;
        T* p;
    public:
    ptr(){
        cnt=nullptr;
        }
    ptr(T* t){
        cnt=new int(1);
        p=t;
        }
    ptr(const ptr &t){
        cnt=t.cnt;
        (*cnt)++;
        p=t.p;
        }
    ~ptr(){
        if(cnt&&!--(*cnt)){
            delete cnt;
            delete p;
            }
        }
    ptr& operator=(const ptr &t){
        if(cnt&&!--(*cnt)){
            delete cnt;
            delete p;
            }
        cnt=t.cnt;
        (*cnt)++;
        printf("= %d\n",*cnt);
        p=t.p;
        }
    ptr& operator=(T* t){
        if(cnt&&!--(*cnt)){
            delete cnt;
            delete p;
            }
        cnt=new int(1);
        p=t;
        }
    T* operator->(){
        return p;
        }
    T& operator*(){
        return *p;
        }
    bool operator==(const ptr &t){
        return p==t.p;
        }
    };

//最小包覆圓
typedef pair<double,double> par;
typedef pair<double,double> vec;
typedef pair<double,par> pr;
inline double crs(par &o,par &a,par &b){
    return (a.f-o.f)*(b.s-o.s)-(a.s-o.s)*(b.f-o.f);
    }
inline double dot(vec a,vec b){
    return a.f*b.f+a.s*b.s;
    }
inline vec ptv(par &a,par &b){
    return par(b.f-a.f,b.s-a.s);
    }
inline double dis2(par &a,par &b){
    return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);
    }
inline double dis2(vec x){
    return (x.f)*(x.f)+(x.s)*(x.s);
    }
inline par mid(par &a,par &b){
    return par((a.f+b.f)/2,(a.s+b.s)/2);
    }
inline par outmid(par &a,par &b,par &c){
    double a2=dis2(a),b2=dis2(b),c2=dis2(c);
    double di=(a.f*b.s+b.f*c.s+c.f*a.s-a.f*c.s-b.f*a.s-c.f*b.s)*2;
    return par((a2*b.s+b2*c.s+c2*a.s-a2*c.s-b2*a.s-c2*b.s)/di,(a.f*b2+b.f*c2+c.f*a2-a.f*c2-b.f*a2-c.f*b2)/di);
    }
par nod[1000005],st[10005];
typedef pair<par,double> cir;//c,r^2
inline cir getcir(par &a,par &b,par &c){
    if(dot(ptv(a,b),ptv(a,c))<=0)
        return cir(mid(b,c),dis2(b,c)/4);
    if(dot(ptv(b,c),ptv(b,a))<=0)
        return cir(mid(a,c),dis2(a,c)/4);
    if(dot(ptv(c,a),ptv(c,b))<=0)
        return cir(mid(a,b),dis2(a,b)/4);
    double a2=a.f*a.f+a.s*a.s,b2=b.f*b.f+b.s*b.s,c2=c.f*c.f+c.s*c.s;
    par o=outmid(a,b,c);
    return cir(o,dis2(o,a));
    }
inline bool incir(cir &c,par &x){
    return dis2(x,c.f)-c.s<=0.00001;
    }
int main(){
    int n,m;
    while(~scanf("%d%d",&m,&n),n||m){
        for(int i=0;i<n;i++)
            scanf("%lf%lf",&nod[i].f,&nod[i].s);
        sort(nod,nod+n);
        int p=0;
        for(int i=0;i<n;i++){
            while(p>1&&crs(st[p-2],st[p-1],nod[i])<0)
                p--;
            st[p++]=nod[i];
            }
        int q=p;
        for(int i=n-2;i>=0;i--){
            while(p>q&&crs(st[p-2],st[p-1],nod[i])<0)
                p--;
            st[p++]=nod[i];
            }
        p--;
        random_shuffle(st,st+p);
        bool run=1,cnt=0;
        cir c(st[0],0);
        for(int i=0;i<p;i++){
            if(incir(c,st[i]))continue;
            c=cir(par((st[i].f+st[0].f)/2,(st[i].s+st[0].s)/2),dis2(st[i],st[0])/4);
            for(int j=1;j<i;j++){
                if(incir(c,st[j]))continue;
                c=cir(par((st[i].f+st[j].f)/2,(st[i].s+st[j].s)/2),dis2(st[i],st[j])/4);
                for(int k=0;k<j;k++){
                    if(incir(c,st[k]))continue;
                    c=getcir(st[i],st[j],st[k]);
                }
            }
        }
    printf("%.3f\n",sqrt(c.s));
    }

//Dinic Flow O(V^2*E)
void add(int a, int b, int c){
    nod[a].push_back(pr(par(b,c),nod[b].size()));
    nod[b].push_back(pr(par(a,0),nod[a].size()-1));
    }
int d[1005];
int BFS(int s,int t){
    memset(d,0,sizeof(d));d[s]=1;
    queue<int>qu;qu.push(s);
    while(!qu.empty()){
        int now=qu.front();qu.pop();
        if(now==t)return d[t];
        for(pr x:nod[now])
            if(x.f.s&&!d[x.f.f])
                d[x.f.f]=d[now]+1,qu.push(x.f.f);
        }
    return 0;
    }
int DFS(int now,int fl,int t){
    if(now==t)return fl;
    int cost=0,f;
    for(pr &x:nod[now])
        if(x.f.s&&d[now]+1==d[x.f.f]&&fl>cost)
            if(f=DFS(x.f.f,min(fl-cost,x.f.s),t))
                x.f.s-=f,nod[x.f.f][x.s].f.s+=f,cost+=f;
    return cost;
    }
int dinic(int s,int t){
    int flow=0;
    while(BFS(s,t))
        flow+=DFS(s,0x7fffffff,t);
    return flow;
    }

//Flow O(V^3)
int mp[N][N]; //this is input
int fl[N][N];
int d[N],e[N];
queue<int>q;
bool iq[N];
int n; //this is input
void preflow(int s,int t){
    for(int j=0;j<n;j++)
        if(mp[s][j]-fl[s][j]&&j!=s){
            int f=mp[s][j]-fl[s][j];
            e[j]+=f;
            fl[s][j]+=f;
            fl[j][s]-=f;
            if(j!=s&&j!=t&&!iq[j])q.push(j),iq[j]=true;
            }
    }
void push(int i, int j){
    int f=min(e[i],mp[i][j]-fl[i][j]);
    e[i]-=f;
    e[j]+=f;
    fl[i][j]+=f;
    fl[j][i]-=f;
    }
void relabel(int i){
    d[i]=n*2;
    for(int j=0;j<n;j++)
        if(mp[i][j]-fl[i][j])
            d[i]=min(d[i],d[j]);
    d[i]++;
    }
void discharge(int i,int s,int t){
    while(e[i]){
        for(int j=0;j<n;j++)
            if(d[i]==d[j]+1&&mp[i][j]-fl[i][j]){
                push(i,j);
                if(j!=s&&j!=t&&!iq[j])q.push(j),iq[j]=true;
                if(!e[i])return;
                }
        relabel(i);
        }
    }
int max_flow(int s, int t,bool clean=true){
    if(clean)
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                fl[i][j]=0;
    for(int i=0;i<n;i++)
        e[i]=d[i]=iq[i]=0;
    while(!q.empty())q.pop();
    d[s]=n-1;
    preflow(s,t);
    while(!q.empty()){
        int i=q.front();
        q.pop();
        iq[i]=false;
        if(e[i]&&i!=s&&i!=t)
            discharge(i,s,t);
        }
    return e[t];
    }
int lf[N][N],uf[N][N]; //lf<=fl<=uf //this is input
int du[N];
bool bounded_flow_ok(){
    for(int i=0;i<n;i++)
        du[i]=0; //du[x]=lf[*][x]-lf[x][*]
    memset(mp,0,sizeof(mp));
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            mp[i][j]=uf[i][j]-lf[i][j],
            du[j]+=lf[i][j],
            du[i]-=lf[i][j];
    int sum=0;
    for(int i=0;i<n;i++){
        if(du[i]>0)
            mp[n][i]=du[i],sum+=du[i];
        else if(du[i]<0)
            mp[i][n+1]=-du[i];
    }
    n+=2;
    int res=max_flow(n-2,n-1);
    n-=2;
    return res==sum;
    }
int bounded_flow(int s,int t){
    uf[t][s]=0x7fffffff;
    lf[t][s]=0;
    if(!bounded_flow_ok())return -1;
    int ans=fl[t][s];
    fl[s][t]+=fl[t][s];
    fl[t][s]=0;
    mp[t][s]=0;
    ans+=max_flow(s,t,false);
    return ans;
    }

//link-cut-treap O(lg^2 N)
typedef struct node* ptr;
ptr nil=NULL;
struct node{
    ptr l,r,fa,sl;
    unsigned int sz;
    bool sptag,rev;
    int val,sig;
    bool zer;
    node(int _val=0,int _sig=0,ptr _fa=nil):l(nil),r(nil),fa(_fa),sl(nil),sz(1),sptag(0),rev(0),val(_val),sig(_sig),zer(0){}
    inline void chrev(){
        if(rev){
            rev=0;
            swap(l,r);
            if(l)l->rev^=1;
            if(r)r->rev^=1;
            }
        }
    inline void push(){
        chrev();
        fa=nil;
        if(zer){
            zer=0;
            if(l)l->zer=1,l->val=0,l->sig=0;
            if(r)r->zer=1,r->val=0,r->sig=0;
            }
        }
    inline void pull(){
        sz=(l?l->sz:0)+(r?r->sz:0)+1;
        sig=(l?l->sig:0)+(r?r->sig:0)+val;
        if(l)l->fa=this;
        if(r)r->fa=this;
        }
    ptr top(){
        ptr now=this;
        if(fa)now=fa->top();
        chrev();
        return now;
        }
    ptr left(){
        chrev();
        if(l)return l->left();
        return this;
        }
    ptr right(){
        chrev();
        if(r)return r->right();
        return this;
        }
    ptr next(){
        top();
        if(r)return r->left();
        ptr now=this;
        while(now->fa)
            if(now->fa->l==now)return now->fa;
            else now=now->fa;
        return nil;
        }
    ptr pre(){
        top();
        if(l)return l->right();
        ptr now=this;
        while(now->fa)
            if(now->fa->r==now)return now->fa;
            else now=now->fa;
        return nil;
        }
    };
ptr merge(ptr a,ptr b){
    static unsigned int S=rand();
    if(!a)return b;if(!b)return a;
    if((S++)%(a->sz+b->sz)<a->sz){
        a->push();
        a->r=merge(a->r,b);
        a->pull();
        return a;
        }
    else{
        b->push();
        b->l=merge(a,b->l);
        b->pull();
        return b;
        }
    }
void split(ptr now,ptr &a,ptr &b){
    if(!now)a=b=nil;
    else if(!now->sptag){
        a=now;
        a->push();
        split(now->r,a->r,b);
        a->pull();
        }
    else{
        now->sptag=0;
        b=now;
        b->push();
        split(now->l,a,b->l);
        b->pull();
        }
    }
void split(ptr now,ptr cut,ptr &a,ptr &b){
    if(cut){
        cut->sptag=1;
        while(cut!=now){
            if(cut->fa->l==cut)
                cut->fa->sptag=1;
            cut=cut->fa;
            }
        split(now,a,b);
        }
    else a=now,b=nil;
    }
void cuthl(ptr now){
    ptr rot=now->top(),a,b;
    split(rot,now->next(),a,b);
    if(b)b->left()->sl=a->right();
    }
ptr access(ptr now){
    cuthl(now);
    ptr rot=now->top();
    now=rot->left();
    if(now->sl)
        return merge(access(now->sl),rot);
    return rot;
    }
ptr root(ptr now){
    access(now);
    return now->top()->left();
    }
void chroot(ptr now){
    ptr p=access(now);
    swap(p->left()->sl,p->right()->sl);
    p->rev^=1;
    }
void cut(ptr x,ptr y){
    ptr a,b;
    if(access(x),x->pre()==y){
        split(x,x,a,b);
        b->left()->sl=nil;
        }
    else if(access(y),y->pre()==x){
        split(y,y,a,b);
        b->left()->sl=nil;
        }
    }
void join(ptr now,ptr to){
    //if(now!=root(now))throw("error");
    now->sl=to;
    }	

//tarjan
#define N 100005
int mod = 1000000007 ;
vector<int> s[N],scc[N],g[N];
stack<int> sta;
int dfs_cnt=0,pre[N]={0},sccno[N]={0},scc_cnt=0;
int dfs(int u,int fa){
    int lowu,lowv,i;
    lowu=pre[u]=++dfs_cnt;
    sta.push(u);
    for(i=0;i<s[u].size();i++){
        int v=s[u][i];
        if(v==fa) continue;
        if(pre[v]==0){
            lowv=dfs(v,u);
            lowu=min(lowu,lowv);
        }
        else if(pre[v]<pre[u] && sccno[v]==0){
            lowu=min(lowu,pre[v]);
        }
    }
    if(lowu==pre[u]){
        ++scc_cnt;
        while(sta.size()){
            int x=sta.top();
            sta.pop();
            sccno[x]=scc_cnt;
            scc[scc_cnt].push_back(x);
            if(x==u) break;
        }
    }
    return lowu;
}

//重心剖分
vector<par>nod[100005];
vector<int>gnod[100005];
int qu[100005],fa[100005];
int us[100005];
int qf=0,qe=0;
int sz[100005],msz[100005];
void bfs(int now){
    qf=0,qe=0;
    qu[qe++]=now;
    fa[now]=-1;
    sz[now]=1;
    msz[now]=0;
    while(qf!=qe){
        int nw=qu[qf++];
        for(auto &x:nod[nw]){
            if(!us[x.f]&&x.f!=fa[nw])
                qu[qe++]=x.f,fa[x.f]=nw,sz[x.f]=1,msz[x.f]=0;
            }
        }
    }
gp_hash_table<int,long long int> dis[100005];
vector<int>way[100005];
int fun(int now){
    bfs(now);
    for(int i=qe-1;i>=0;i--)
        if(~fa[qu[i]])
            sz[fa[qu[i]]]+=sz[qu[i]],msz[fa[qu[i]]]=max(msz[fa[qu[i]]],sz[qu[i]]+1);
    int g=now,mi=0x7fffffff;
    for(int i=0;i<qe;i++)
        if(mi>max(msz[qu[i]],qe-sz[qu[i]]))
            mi=max(msz[qu[i]],qe-sz[qu[i]]),g=qu[i];
    bfs(g);
    for(int i=0;i<qe;i++)
        way[qu[i]].push_back(g);
    for(int i=0;i<qe;i++)
        for(auto &x:nod[qu[i]])
            if(x.f!=fa[qu[i]]&&!us[x.f])
                dis[g][x.f]=dis[g][qu[i]]+x.s;
    us[g]=1;
    for(auto &x:nod[g])
        if(!us[x.f])
            gnod[g].push_back(fun(x.f));
    return g;
    }
long long int sig[100005];
int cnt[100005];
gp_hash_table<int,long long int> sg2[100005];
gp_hash_table<int,int> ct2[100005];
void add(int to){
    int sz=way[to].size();
    for(int i=0;i<sz;i++){
        int x=way[to][i];
        sig[x]+=dis[x][to];
        cnt[x]++;
        if(i==sz-1)break;
        sg2[x][way[to][i+1]]+=dis[x][to];
        ct2[x][way[to][i+1]]++;
        }
    }
long long int qry(int to){
    long long int ret=sig[to];
    int sz=way[to].size();
    for(int i=0;i<sz-1;i++){
        int x=way[to][i],y=way[to][i+1];
        ret+=sig[x]-sg2[x][y]+1ll*(cnt[x]-ct2[x][y])*dis[x][to];
        }
    return ret;
    }
int on[100005];
int main(){
    int n,q;
    scanf("%d%d",&n,&q);
    for(int i=1;i<n;i++){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        nod[a].push_back(par(b,c));
        nod[b].push_back(par(a,c));
        }
    int g=fun(0);
    while(q--){
        int m,l;
        scanf("%d%d",&m,&l);
        if(m==1){
            if(on[l])
                continue;
            on[l]=1;
            add(l);
            }
        else
            printf("%lld\n",qry(l));
        }
    return 0;
    }

//樹鏈剖分
typedef pair<int,int>par;
typedef pair<int,par>pr;
int bs[100005];
int bos(int k){
    return k==bs[k]?bs[k]:(bs[k]=bos(bs[k]));
    }
pr qs[300005];
vector<int>nod[100005];
int sz[100005];
int fa[20][100005];
int lv[100005];
void F(int now,int f=0,int l=1){
    lv[now]=l;
    fa[0][now]=f;
    for(int i=1;i<20;i++)
        fa[i][now]=fa[i-1][fa[i-1][now]];
    sz[now]=1;
    int ms=nod[now].size();
    for(int i=0;i<ms;i++){
        int x=nod[now][i];
        if(x==f){
            swap(nod[now][i],nod[now].back());
            nod[now].pop_back();
            i--;ms--;
            continue;
            }
        F(x,now,l+1);
        sz[now]+=sz[x];
        }
    sort(nod[now].begin(),nod[now].end(),[&](int a,int b)->bool{return sz[b]<sz[a];});
    }
int sgnt;
vector<int>ve[100005];
int sgid[100005],sgvp[100005];
void G(int now,int sid){
    sgid[now]=sid;
    sgvp[now]=ve[sid].size();
    ve[sid].push_back(now);
    int ms=nod[now].size();
    if(!ms)return;
    G(now[nod][0],sid);
    for(int i=1;i<ms;i++)
        G(nod[now][i],sgnt++);
    }
vector<int> sg[100005];
void mkt(int sid,int l,int r,int i=0){
    if(l==r){
        sg[sid][i]=1;
        return;
        }
    int mid=(l+r)/2;
    mkt(sid,l,mid,i*2+1);
    mkt(sid,mid+1,r,i*2+2);
    sg[sid][i]=sg[sid][i*2+1]+sg[sid][i*2+2];
    }
void cle(int sid,int s,int e,int l,int r,int i=0){
    if(s==l&&e==r)
        sg[sid][i]=0;
    if(!sg[sid][i])
        return ;
    int mid=(l+r)/2;
    if(e<=mid)cle(sid,s,e,l,mid,i*2+1);
    else if(mid<s)cle(sid,s,e,mid+1,r,i*2+2);
    else cle(sid,s,mid,l,mid,i*2+1),cle(sid,mid+1,e,mid+1,r,i*2+2);
    sg[sid][i]=sg[sid][i*2+1]+sg[sid][i*2+2];
    }
int qry(int sid,int s,int e,int l,int r,int i=0){
    if((s==l&&e==r)||(!sg[sid][i]))
        return sg[sid][i];
    int mid=(l+r)/2;
    if(e<=mid)return qry(sid,s,e,l,mid,i*2+1);
    else if(mid<s)return qry(sid,s,e,mid+1,r,i*2+2);
    else return qry(sid,s,mid,l,mid,i*2+1)+qry(sid,mid+1,e,mid+1,r,i*2+2);
    }
int len_to_root(int now){
    int sid=sgid[now];
    int ret=qry(sid,0,sgvp[now],0,ve[sid].size()-1);
    if(fa[0][ve[sid][0]]!=ve[sid][0])
        ret+=len_to_root(fa[0][ve[sid][0]]);
    return ret;
    }
void cl(int now,int to){
    int sid=sgid[now];
    if(sid!=sgid[to])
        cle(sid,0,sgvp[now],0,ve[sid].size()-1),cl(fa[0][ve[sid][0]],to);
    else if(to!=now)
        cle(sid,sgvp[to]+1,sgvp[now],0,ve[sid].size()-1);
    }
int lca(int a,int b){
    if(lv[a]>lv[b])swap(a,b);
    for(int x=lv[b]-lv[a],y=x&-x;y;x^=y,y=x&-x)
        b=fa[__lg(y)][b];
    if(a==b)return a;
    for(int i=19;i>=0;i--)
        if(fa[i][a]!=fa[i][b])
            a=fa[i][a],b=fa[i][b];
    if(a==b)throw("error");
    if(fa[0][a]!=fa[0][b])throw("GG");
    return fa[0][a];
    }
int main(){
    int n,q;
    scanf("%d%d",&n,&q);
    for(int i=0;i<n;i++)
        bs[i]=i;
    for(int i=0;i<q;i++){
        int t,a,b;
        scanf("%d%d%d",&t,&a,&b);a--;b--;
        qs[i]=pr(t,par(a,b));
        if(t==1&&bos(a)!=bos(b)){
            bs[bos(a)]=bs[bos(b)];
            nod[a].push_back(b);
            nod[b].push_back(a);
            }
        }
    for(int i=0;i<n;i++)
        if(!lv[i])
            F(i,i);
    sgnt=1;
    for(int i=0;i<n;i++)
        if(!sgid[i])	
            G(i,sgnt++);
    for(int i=1;i<sgnt;i++){
        sg[i].resize(ve[i].size()*4),
        mkt(i,0,ve[i].size()-1);
        }
    for(int i=0;i<n;i++)
        bs[i]=i;
    for(int i=0;i<q;i++){
        int t=qs[i].f,a=qs[i].s.f,b=qs[i].s.s;
        if(t==1){
            if(bos(a)!=bos(b))
                bs[bos(a)]=bs[bos(b)];
            else{
                int c=lca(a,b);
                cl(a,c),cl(b,c);
                }
            }
        if(t==2){
            if(bos(a)!=bos(b))
                puts("-1");
            else{
                int c=lca(a,b);
                printf("%d\n",len_to_root(a)+len_to_root(b)-len_to_root(c)*2);
                }
            }
        }
    return 0;
    }

//樹鍊剖分2
typedef pair<int,int>par;
typedef pair<par,int>pr;
const int N=100005;
vector<par> nod[N];
int lv[N],fa[20][N],sz[N];
int ar[N];
int br[N];
int cr[N];
void F(int now,int f=0,int l=0){
    lv[now]=l;
    fa[0][now]=f;
    for(int i=1;i<20;i++)
        fa[i][now]=fa[i-1][fa[i-1][now]];
    sz[now]=1;
    int ms=nod[now].size();
    for(int i=0;i<ms;i++){
        int x=nod[now][i].f;
        if(x==f){
            ar[now]=nod[now][i].s;
            swap(nod[now][i],nod[now].back());
            nod[now].pop_back();
            i--;ms--;
            continue;
            }
        F(x,now,l+1);
        sz[now]+=sz[x];
        }
    sort(nod[now].begin(),nod[now].end(),[&](par a,par b)->bool{return sz[b.f]<sz[a.f];});
    }
//vector<int>lnk[N];
int lnhd[N];
int lnid[N];
int lncnt=0;
int sgid[N];
int sgcnt=0;
void G(int now,int id){
    cr[sgcnt]=ar[now];
    sgid[now]=sgcnt++;
    lnid[now]=id;
    //lnk[id].push_back(now);
    int ms=nod[now].size();
    if(!ms)
        return;
    G(now[nod][0].f,id);
    for(int i=1;i<ms;i++)
        lnhd[lncnt]=nod[now][i].f,
        G(nod[now][i].f,lncnt++);
    }
int lca(int a,int b){
    if(lv[a]>lv[b])swap(a,b);
    for(int x=lv[b]-lv[a],y=x&-x;y;x^=y,y=x&-x)
        b=fa[__lg(y)][b];
    if(a==b)return a;
    for(int i=19;i>=0;i--)
        if(fa[i][a]!=fa[i][b])
            a=fa[i][a],b=fa[i][b];
    return fa[0][a];
    }
void lis(vector<pr> &ve,int c,int a,int b){//a to b
    while(lnid[a]!=lnid[b])
        //ve.push_back(pr(par(sgid[lnk[lnid[a]][0]],sgid[a]),c)),
        ve.push_back(pr(par(sgid[lnhd[lnid[a]]],sgid[a]),c)),
        a=fa[0][lnhd[lnid[a]]];
    if(a!=b)
        ve.push_back(pr(par(sgid[b]+1,sgid[a]),c));
    }
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        int n,m;
        scanf("%d%d",&n,&m);
        m-=n-1;
        for(int i=0;i<n;i++)
            nod[i].clear();//lnk[i].clear();
        for(int i=0;i<n-1;i++){
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);a--;b--;
            nod[a].push_back(par(b,c));
            nod[b].push_back(par(a,c));
            }
        F(0);
        lncnt=0;
        sgcnt=0;
        lnhd[0]=0,G(0,lncnt++);
        vector<pr> ve;
        for(int i=0;i<m;i++){
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);a--;b--;
            int p=lca(a,b);
            lis(ve,c,a,p);
            lis(ve,c,b,p);
            }
        sort(ve.begin(),ve.end());
        priority_queue<par,vector<par>,greater<par>>pq;
        int vp=0,vsz=ve.size();
        for(int i=1;i<n;i++){
            br[i]=0x7fffffff;
            while(vp<vsz&&ve[vp].f.f==i){
                pq.push(par(ve[vp].s,ve[vp].f.s));
                vp++;
                }
            while(!pq.empty()&&pq.top().s<i)
                pq.pop();
            if(!pq.empty())
                br[i]=pq.top().f;
            }
        int ans=0;
        for(int i=1;i<n;i++)
            if(br[i]<cr[i])
                ans+=cr[i]-br[i];
        printf("%d\n",ans);
        }
    return 0;
    }


//Modable Int
struct Int{
    int num;
    Int(long long int x):num((x%MOD+MOD)%MOD){}
    Int(int x):num((x%MOD+MOD)%MOD){}
    Int():num(0){}
    explicit operator int&(){return num;}
    Int& operator+=(Int x){
        num=(num+x.num)%MOD;
        return *this;
        }
    Int operator+(Int x){
        Int ret((num+x.num)%MOD);
        return ret;
        }
    Int& operator-=(Int x){
        num=((num-x.num)%MOD+MOD)%MOD;
        return *this;
        }
    Int operator-(Int x){
        Int ret(((num-x.num)%MOD+MOD)%MOD);
        return ret;
        }
    Int& operator*=(Int x){
        num=(1ll*num*x.num)%MOD;
        return *this;
        }
    Int operator*(Int x){
        Int ret((1ll*num*x.num)%MOD);
        return ret;
        }
    };

//某輸入輸出優化
#define qbs 10000100
inline char getc(){ static char buf[qbs];static unsigned int q=qbs; if(qbs==q) fread(buf,qbs,1,stdin),q=0; return buf[q++]; }
inline void readuint(unsigned int& a){ a=0; char p=getc(); while(p>'9' || p<'0') p=getc(); while(p<='9'&&p>='0') a=a*10+p-'0',p=getc(); }
inline void readuint(unsigned long long& a){ a=0; char p=getc(); while(p>'9' || p<'0') p=getc(); while(p<='9'&&p>='0') a=a*10+p-'0',p=getc(); }
inline void putc(char p,bool e=0){ static char buf[qbs+10];static unsigned int q=0; if(~p) buf[q++]=p; if((e&&q) || qbs==q) fwrite(buf,q,1,stdout),q=0; }
inline void printuint(unsigned int a){if(a>=10) printuint(a/10); putc(a%10+'0');}
inline void printuint(unsigned long long a){if(a>=10) printuint(a/10); putc(a%10+'0');}

//黑魔法樹(可split/join/update)
#pragma GCC optimize ("O3")
#include<bits/stdc++.h>
//#include <ext/pb_ds/detail/standard_policies.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
//#include<ext/pb_ds/priority_queue.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/rope>
#pragma GCC optimize ("O3")
//#pragma GCC diagnostic error "-std=c++14"
#define tu(x,y) get<y>(x)
#define f first
#define s second
using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;
typedef pair<int,int>par;
typedef pair<int,par>pr;
typedef tuple<int,int,int>tup;
typedef pair<int&,int&>pa;
struct meta{
    int size=0;
    int val=0;
    };
template<class CNod,class Nod,class Cmp,class _>
struct my_node_update{
    typedef meta metadata_type;
    virtual CNod node_begin() const = 0;
    virtual CNod node_end() const = 0;
    void operator()(Nod it, CNod end_it){
        auto l=it.get_l_child();
        auto r=it.get_r_child();
        metadata_type left,right;
        if(l!=end_it) left =l.get_metadata();
        if(r!=end_it) right=r.get_metadata();
        const_cast<metadata_type&>(it.get_metadata()).size=left.size+right.size+1;
        const_cast<metadata_type&>(it.get_metadata()).val=max(((*it)->s),max(left.val,right.val));
        //const_cast<metadata_type&>(it.get_metadata()).val=max(**it,max(left.val,right.val));
        }
    int order_of_key(int x){
        int ans=0;
        auto it=node_begin();
        while(it!=node_end()){
            auto l=it.get_l_child();
            auto r=it.get_r_child();
            if(Cmp()(x,(*it)->f)){
            //if(Cmp()(x,**it)){
                it=l;
                }
            else{
                ans++;
                if(l!=node_end()) ans+=l.get_metadata().size;
                it=r;
                }
            }
        return ans;
        }
    int qry(){
        int ans=-1;
        auto it=node_begin();
        if(it!=node_end())
            ans=it.get_metadata().val;
        return ans;
        }
    };
int main(){
    //tree<int,int,less<int>,rb_tree_tag,my_node_update>tre;
    //tree<int,int,less<int>,rb_tree_tag,tree_order_statistics_node_update>tre;
    tree<int,int,less<int>,rb_tree_tag,my_node_update>tre,tr2;
    for(int i=0;i<1000000;i++)
        tre.insert(par(i,i));
    printf("%d %d\n",tre.qry(),tr2.qry());
    tre.split(500,tr2);
    printf("%d %d\n",tre.size(),tr2.size());
    printf("%d %d\n",tre.qry(),tr2.qry());
    tre.join(tr2);
    printf("%d %d\n",tre.qry(),tr2.qry());
    //tre.insert(par(0,0));
    //tre.order_of_key(0);
    //tre.find_by_order(0);
    return 0;
    }

//Directed_MST
const int N=305;
const int inf=0x7fffffff;
struct edge{
    int u,v,w;
    };
int in[N],num[N],pre[N],vis[N];
edge edg[N*N];
int Directed_MST(int s,int n,int m){
    int ans=0;
    for(int i=0;i<m;i++){
        if(edg[i].u==edg[i].v)
            ans+=min(0,edg[i].w),
            swap(edg[i],edg[--m]),i--;
        }
    while(true){
        for(int i=0;i<n;i++)
            in[i]=inf;
        for(int i=0;i<m;i++){
            int &u=edg[i].u;
            int &v=edg[i].v;
            if(edg[i].w<in[v]){
                pre[v]=u;
                in[v]=edg[i].w;
                }
            }
        for(int i=0;i<n;i++)
            if(in[i]==inf&&i!=s)
                return -1;
        int cnt=0;
        fill(num,num+n,-1);
        fill(vis,vis+n,-1);
         in[s]=0;
         for(int i=0;i<n;i++){
             ans+=in[i];
             int v=i;
             while(!~vis[v]&&v!=s){
                 vis[v]=i;
                 v=pre[v];
                }
             if(v!=s&&vis[v]==i){
                 for(int u=pre[v];u!=v;u=pre[u])
                     num[u]=cnt;
                 num[v]=cnt++;
                }
            }
         if(!cnt)
             break;
         for(int i=0;i<n;i++)
             if(!~num[i])
                 num[i]=cnt++;
         for(int i=0;i<m;){
             int &u=edg[i].u;
             int &v=edg[i].v;
             int ov=v;
             u=num[u];
             v=num[v];
             if(u!=v)
                 edg[i++].w-=in[ov];
            else
                swap(edg[i],edg[--m]);
            }
        n=cnt;
        s=num[s];
        }
    return ans;
    }

//計算幾何模板
typedef double D;
//typedef __float128 D;
//D abs(D a){return a<0?-a:a;}
/*typedef long double D;
#define atan2 atan2l
#define sin sinl
#define cos cosl
#define acos acosl
#define sqrt sqrtl*/
const D pi=acos(-1);
const D eps=1e-9;
bool eql(D a,D b){return abs(a-b)<eps;}
struct pnt;
struct vec;
struct rng;
struct pnt{
    D x,y;
    vec operator-(pnt p);
    pnt operator+(vec p);
    pnt operator-(vec p);
    };
struct vec{
    D x,y;
    vec& operator+=(vec v){x+=v.x,y+=v.y;return *this;}
    vec operator+(vec v){return vec{x+v.x,y+v.y};}
    vec& operator-=(vec v){x-=v.x,y-=v.y;return *this;}
    vec operator-(vec v){return vec{v.x-x,v.y+y};}
    D dot(vec v){return x*v.x+y*v.y;}
    D crs(vec v){return x*v.y-y*v.x;}
    vec rot(D d){return vec{cos(d)*x-sin(d)*y,sin(d)*x+cos(d)*y};}
    vec rot90(){return vec{-y,x};}
    D ang(){D tmp=atan2(y,x);return tmp<0?tmp+pi*2:tmp;}
    vec mir(D d){return vec{cos(2*d)*x+sin(2*d)*y,sin(2*d)*x-cos(2*d)*y};}
    vec unit(){D r=sqrt(x*x+y*y);return vec{x/r,y/r};}
    };
struct rng{
    D beg,len;
    void init(D bg,D ed){
        beg=bg;
        len=(ed>=bg?ed-bg:ed-bg+pi*2);
        }
    D l(){return beg;}
    D r(){return beg+len<pi*2?beg+len:beg+len-pi*2;}
    rng its(rng g){
        D tl=l(),tr=r(),gl=g.l(),gr=g.r();
        D rtl,rtr;
        if((beg<=gl&&gl<=beg+len)||(beg<=gl+pi*2&&gl+pi*2<=beg+len))
            rtl=gl;
        else if((g.beg<=tl&&tl<=g.beg+g.len)||(g.beg<=tl+pi*2&&tl+pi*2<=g.beg+g.len))
            rtl=tl;
        else
            return rng{log(-1),log(-1)};
        if((beg<=gr&&gr<=beg+len)||(beg<=gr+pi*2&&gr+pi*2<=beg+len))
            rtr=gr;
        else if((g.beg<=tr&&tr<=g.beg+g.len)||(g.beg<=tr+pi*2&&tr+pi*2<=g.beg+g.len))
            rtr=tr;
        else
            return rng{log(-1),log(-1)};
        if(abs(rtr-rtl)<eps)
            return rng{log(-1),log(-1)};
        rng ret;
        ret.init(rtl,rtr);
        return ret;
        }
    };
vec pnt::operator-(pnt p){return vec{x-p.x,y-p.y};}
pnt pnt::operator+(vec v){return pnt{x+v.x,y+v.y};}
pnt pnt::operator-(vec v){return pnt{x-v.x,y-v.y};}
pnt its(pnt p1,vec v1,pnt p2,vec v2){
    D a=v1.y,b=-v1.x,e=a*p1.x+b*p1.y;
    D c=v2.y,d=-v2.x,f=c*p2.x+d*p2.y;
    if((a*d-b*c)==0)
        return pnt{log(-1),log(-1)};
    D x=(e*d-b*f)/(a*d-b*c),y=(a*f-e*c)/(a*d-b*c);
    return pnt{x,y};
    }
D reang(D d){
    if(d<0)d+=pi*2;
    if(d>=pi*2)d-=pi*2;
    return d;
    }
vector<pnt> convex(vector<pnt>og){
    sort(og,og+n,[](pnt a,pnt b){
        if(a.x==b.x)return a.y<b.y;
        return a.x<b.x;
        });
    vector<pnt>cv(og.size()+1);
    int p=0;
    for(int i=0;i<n;i++){
        while(p>1&&(cv[p-1]-cv[p-2]).crs(og[i]-cv[p-2])<=0)p--;
        cv[p++]=og[i];
        }
    int q=p;
    for(int i=n-2;i>=0;i--){
        while(q>p&&(cv[q-1]-cv[q-2]).crs(og[i]-cv[q-2])<=0)q--;
        cv[q++]=og[i];
        }
    cv.resize(q);
    return cv;
    }
//Intersection of two circle
using ld = double; 
vector<pdd> interCircle(pdd o1, double r1, pdd o2, double r2) { 
    ld d2 = (o1 - o2) * (o1 - o2); 
    ld d = sqrt(d2); 
    if (d > r1+r2) return {}; 
    pdd u = 0.5*(o1+o2) + ((r2*r2-r1*r1)/(2*d2))*(o1-o2); 
    double A = sqrt((r1+r2+d) * (r1-r2+d) * (r1+r2-d) * (-r1+r2+d)); 
    pdd v = A / (2*d2) * pdd(o1.S-o2.S, -o1.F+o2.F); 
    return {u+v, u-v}; 
    }
//Intersection of two lines
const double EPS = 1e-9; 
pdd interPnt(pdd p1, pdd p2, pdd q1, pdd q2, bool &res) { 
    double f1 = cross(p2, q1, p1); 
    double f2 = -cross(p2, q2, p1); 
    double f = (f1 + f2); 
    if(fabs(f) < EPS) { 
        res = false; return {}; 
        } 
    res = true; 
    return (f2 / f) * q1 + (f1 / f) * q2; 
    }
//Half Plane Intersection
const double EPS = 1e-9; 
pdd interPnt(Line l1, Line l2, bool &res){ 
    pdd p1, p2, q1, q2; 
    tie(p1, p2) = l1; 
    tie(q1, q2) = l2; 
    double f1 = cross(p2, q1, p1); 
    double f2 = -cross(p2, q2, p1); 
    double f = (f1 + f2); 
    if(fabs(f) < EPS) { 
        res = false; 
        return {0, 0}; 
        } 
    res = true; 
    return (f2 / f) * q1 + (f1 / f) * q2; 
    } 
bool isin(Line l0, Line l1, Line l2) { 
    // Check inter(l1, l2) in l0 
    bool res; pdd p = interPnt(l1, l2, res); 
    return cross(l0.S, p, l0.F) > EPS; 
    } 
/* If no solution, check: 1. ret.size() < 3 
 * Or more precisely, 2. interPnt(ret[0], ret[1])
 * in all the lines. (use (l.S - l.F).cross(p - l.F) > 0 */ 
 vector<Line> halfPlaneInter(vector<Line> lines) { 
     int sz = lines.size(); 
     vector<double> ata(sz), ord(sz); 
     for (int i=0; i<sz; i++) { 
        ord[i] = i;
        pdd d = lines[i].S - lines[i].F; 
        ata[i] = atan2(d.y, d.x);
        } 
    sort(ALL(ord), [&](int i, int j) { 
        if (abs(ata[i] - ata[j]) < EPS) { 
            return cross(lines[i].S, lines[j].S, lines[ i].F) < 0; 
            } 
        return ata[i] < ata[j]; 
        }); 
    vector<Line> fin; 
    for (int i=0; i<sz; i++) { 
        if (!i or fabs(ata[ord[i]] - ata[ord[i-1]]) > EPS) { 
            fin.PB(lines[ord[i]]); 
            } 
        } 
    deque<Line> dq; 
    for (int i=0; i<SZ(fin); i++) { 
        while(SZ(dq) >= 2 and not isin(fin[i], dq[SZ(dq)-2], dq[SZ(dq) -1])) dq.pop_back(); 
        while(SZ(dq) >= 2 and not isin(fin[i], dq[0], dq[1])) dq.pop_front(); 
        dq.push_back(fin[i]); 
        } 
    while (SZ(dq) >= 3 and not isin(dq[0], dq[SZ(dq)-2], dq[SZ(dq)-1])) dq.pop_back(); 
    while (SZ(dq) >= 3 and not isin(dq[SZ(dq)-1], dq[0], dq[1])) dq.pop_front(); 
    vector<Line> res(ALL(dq)); 
    return res;
    }

//遍歷子集
for(int j=c;j;j=c&j-1);

//zkw
void build(){
    for(M=1;M<=n+1;M<<=1);
    for(int i=1;i<=n;i++)
        zkw[id[i].f+M]=one<<col[i];
    for(int i=M-1;i;i--)
        zkw[i]=zkw[i<<1]^zkw[i<<1|1];
    }
void update(int x,__int128 val){
    zkw[x+=M]^=val;
    for(x>>=1;x>=1;x>>=1)
        zkw[x]=zkw[x<<1]^zkw[x<<1|1];
    }
__int128 qry(int l,int r){
    l=l+M-1,r=r+M+1;
    __int128 ans=0;
    for(;l^r^1;l>>=1,r>>=1){
        if(~l&1)ans^=zkw[l^1];
        if(r&1) ans^=zkw[r^1];
        }
    return ans;
    }

//KMP
#define N 1000000 + 100
char str[N];
int next[N];
void get_next(int m)
{
   int j ,k;
   j = 0 ,k = -1;
   next[0] = -1;
   while(j < m)
   {
      if(k == -1 || str[j] == str[k])
      next[++j] = ++k;
      else
      k = next[k];
   }
   return ;
}

//DominatorTree::build(int n,int s,vector<int> nod[],vector<int> rnod[],vector<int> result[])
const int N=200000+10;
namespace DominatorTree{
    int dfn[N],pre[N],pt[N],sz;
    int semi[N],dsu[N],idom[N],best[N];
    int get(int x) {
        if (x == dsu[x]) return x;
        int y = get(dsu[x]);
        if (semi[best[x]] > semi[best[dsu[x]]]) best[x] = best[dsu[x]];
        return dsu[x] = y;
        }
    void dfs(int u,const vector<int> succ[]) {
        dfn[u] = sz;
        pt[sz ++] = u;
        for (auto &v: succ[u]) if (!~dfn[v]) {
                dfs(v,succ);
                pre[dfn[v]] = dfn[u];
                }
        }
    void tarjan(const vector<int> pred[],vector<int> dom[]) {
        for (int j = sz - 1,u; u = pt[j],j > 0; -- j) {
            for (auto &tv: pred[u]) if (~dfn[tv]) {
                    int v = dfn[tv];
                    get(v);
                    if (semi[best[v]] < semi[j]) semi[j] = semi[best[v]];
                    }
            dom[semi[j]].push_back(j);
            int x = dsu[j] = pre[j];
            for (auto &z: dom[x]) {
                get(z);
                if (semi[best[z]] < x) idom[z] = best[z];
                else idom[z] = x;
                }
            dom[x].clear();
            }
        for (int i = 1; i < sz; ++ i) {
            if (semi[i] != idom[i]) idom[i] = idom[idom[i]];
            dom[idom[i]].push_back(i);
            }
        }
    void build(int n,int s,const vector<int> succ[],const vector<int> pred[],vector<int> dom[]) {
        for (int i = 0; i < n; ++ i) {
            dfn[i] = -1;
            dom[i].clear();
            dsu[i] = best[i] = semi[i] = i;
            }
        sz = 0;
        dfs(s,succ);
        tarjan(pred,dom);
        }
    }

//FFT&NNT
template <typename T> int arrange(vector<T>& a){
    int n=a.size();
    for(int i=1,x=0,y=0;i<=n;i++){
        if(x>y) swap(a[x],a[y]);
        x^=i&-i;
        y^=n/(i&-i)>>1;
        }
    return n;
    }
class FFT { // 快速傅里叶变换
public:
    typedef complex<double> complex_num;
    void fourier(vector<complex_num>& a, int o){//length of array must be 2^k
        int n=arrange(a);
        const double PI=acos(-1);
        for(int m=1;m<n;m+=m){
            complex_num w=1,e(cos(PI/m),sin(PI/m)*o);
            for(int x=0;x<n;w=1,x+=m+m)
                for(int y=0;y<m;y++,w*=e){
                    complex_num t=w*a[x+y+m];
                    a[x+y+m]=a[x+y]-t;
                    a[x+y]+=t;
                    }
            }
        if(o<0)
            for(int i=0;i<n;i++)
                a[i]/=n;
        }
    vector<int> convolution(const vector<int>& a, const vector<int>& b){
        int n=a.size(),m=b.size();
        int s=1<<(32-__builtin_clz(n+m-2)); // n+m must >=2
        vector<complex_num> u(s),v(s);
        for(int i=0;i<n;i++) u[i]=a[i];
        for(int i=0;i<m;i++) v[i]=b[i];
        fourier(u,+1);
        fourier(v,+1);
        for(int i=0;i<s;i++) u[i]*=v[i];
        fourier(u,-1);
        vector<int> w(n+m-1);
        for(int i=0;i<n+m-1;i++) w[i]=int(u[i].real()+0.5);
        return w;
        }
    };
class NTT { // 数论变换，能求模P下的精确卷积
//int P=605028353,root=3,MAXNUM=262144; 
// Remember coefficient are mod P 
/* 
p=a*2^n+1 
n 2^n p a root 
5 32 97 3 5 
6 64 193 3 5 
7 128 257 2 3 
8 256 257 1 3 
9 512 7681 15 17 
10 1024 12289 12 11 
11 2048 12289 6 11 
12 4096 12289 3 11 
13 8192 40961 5 3 
14 16384 65537 4 3 
15 32768 65537 2 3 
16 65536 65537 1 3 
17 131072 786433 6 10 
18 262144 786433 3 10 (605028353, 2308, 3) 
19 524288 5767169 11 3 
20 1048576 7340033 7 3 
21 2097152 23068673 11 3 
22 4194304 104857601 25 3 
23 8388608 167772161 20 3 
24 16777216 167772161 10 3 
25 33554432 167772161 5 3 (1107296257, 33, 10) 
26 67108864 469762049 7 3 
27 134217728 2013265921 15 31 
*/ 
public:     // P must be prime, and exist k,q that P=q*2^k+1
    static const int P = 786433, G = 10; // G^(P-1)=1 mod P
    int add(int x, int y){
        return x+y<P?x+y:x+y-P;
        }
    int pow(long long a, int e){
        int s=1%P;
        for(a=a%P;e;a=a*a%P,e>>=1)
            if(e&1) s=s*a%P;
        return s;
        }
    void fourier(vector<int>& a){ //length of array must be 2^k
        int n=arrange(a);
        for(int m=1;m<n;m+=m){
            int e=pow(G,(P-1)/m>>1);
            long long w=1;
            for(int x=0;x<n;w=1,x+=m+m)
            for(int y=0;y<m;y++,w=w*e%P){
                int t=w*a[x+y+m]%P;
                a[x+y+m]=add(a[x+y],P-t);
                a[x+y]=add(t,a[x+y]);
                }
            }
        }
    vector<int> convolution(const vector<int>& a, const vector<int>& b){
        int n=a.size(),m=b.size();
        int s=1<<(32-__builtin_clz(n+m-2)); // n+m must >=2
        vector<int> u(s),v(s);
        for(int i=0;i<n;i++) u[i]=a[i];
        for(int i=0;i<m;i++) v[i]=b[i];
        fourier(u);
        fourier(v);
        long long inv=pow(s,P-2);
        for(int i=0;i<s;i++) u[i]=u[i]*inv%P*v[i]%P;
        reverse(u.begin()+1,u.end());
        fourier(u);
        u.erase(u.begin()+n+m-1,u.end());
        return u;
        }
    };

//rk-hash
const int N=100005;
char s[N];
const int MOD=1000000007;
const int A=100001;
int HS[N],P[N];
void mak_HS(int n){
    HS[0]=0;
    P[0]=1;
    for(int i=1;i<=n;i++)
        HS[i]=((1ll*HS[i-1]*A)%MOD+s[i-1])%MOD,
        P[i]=(1ll*P[i-1]*A)%MOD;
    }
int hsh(int l,int r){
    return (0LL+HS[r+1]-(1ll*HS[l]*P[r-l+1])%MOD+MOD)%MOD;
    }

//回文樹
struct palindromic_tree{
	struct node{
		int next[26],suf,len;
		int cnt,pos;
		node(int l=0):suf(0),len(l),cnt(0),pos(-1){
			for(int i=0;i<26;++i)next[i]=0;
            }
        };
	std::vector<node>St;
	std::vector<char>s;
	int last,n;
	palindromic_tree():St(2),last(1),n(0){
		St[0].suf=1;
		St[1].len=-1;
		s.push_back(-1);
        }
	void clear(){
		St.clear();
		s.clear();
		last=1;
		n=0;
		St.push_back(0);
		St.push_back(-1);
		St[0].suf=1;
		s.push_back(-1);
        }
	int get_suf(int x){
		while(s[n-St[x].len-1]!=s[n])x=St[x].suf;
		return x;
        }
	void add(int c){
		s.push_back(c-='a');
		++n;
		int cur=get_suf(last);
		if(!St[cur].next[c]){
			int now=St.size();
			St.push_back(St[cur].len+2);
			St[now].suf=St[get_suf(St[cur].suf)].next[c];
			St[cur].next[c]=now;
			St[now].pos=n-St[now].len;
            }
		last=St[cur].next[c];
		++St[last].cnt;
        }
	void count(){
		std::vector<node>::reverse_iterator i=St.rbegin();
		for(;i!=St.rend();++i){
			St[i->suf].cnt+=i->cnt;
            }
        }
	int size(){
		return St.size()-2;
        }
    };

//Increase Stack size
//stack resize
asm("mov %0,%%exp\n"::"g"(mem+10000000));
//stack resize(linux)
#include <sys/resource.h>
void increase_stack_size(){
    const rlim_t ks=64*104*1024;
    struct rlimt rl;
    int res=getlimit(RLINIT_STACK,&rl);
    if(res==0&&rl.rlim_cur<ks)
        rl.rlim_cur=ks,res=setrlimit(RLIMIT_STACK,&rl);
}

//unordered_map
struct Key { 
    int first,second; 
    Key () {} 
    Key (int _x, int _y) : first(_x), second(_y) {} 
    bool operator == (const Key &b) const { 
        return tie(F,S) == tie(b.F,b.S); 
        } 
    }; 
struct KeyHasher { 
    size_t operator()(const Key& k) const { 
        return k.first + k.second*100000; 
        } 
    }; 
typedef unordered_map<Key,int,KeyHasher> map_t; 
int main(int argc, char** argv){ 
    map_t mp; 
    for (int i=0; i<10; i++) 
        mp[Key(i,0)] = i+1; 
        for (int i=0; i<10; i++) 
        printf("%d\n", mp[Key(i,0)]); 
        return 0; 
    }

//DisjointSet
struct DisjointSet { 
    // save() is like recursive 
    // undo() is like return 
    int n, fa[MXN], sz[MXN]; 
    vector<pair<int*,int>> h; 
    vector<int> sp; 
    void init(int tn) { 
        n=tn; 
        for (int i=0; i<n; i++) { 
            fa[i]=i; sz[i]=1; 
            } 
        sp.clear(); 
        h.clear(); 
        } 
    void assign(int *k, int v) {
         h.PB({k, *k}); *k=v; 
         }
    void save() { 
        sp.PB(SZ(h)); 
        } 
    void undo() { 
        assert(!sp.empty()); 
        int last=sp.back(); 
        sp.pop_back(); 
        while (SZ(h)!=last) { 
            auto x=h.back(); h.pop_back(); *x.F=x.S; 
            } 
        } 
    int f(int x) { 
        while (fa[x]!=x) x=fa[x]; 
        return x; 
        } 
    void uni(int x, int y) { 
        x=f(x); y=f(y); 
        if (x==y) return ; 
        if (sz[x]<sz[y]) swap(x, y); 
        assign(&sz[x], sz[x]+sz[y]); 
        assign(&fa[y], x); 
        } 
    }djs;

//link cut tree
const int MXN = 100005; 
const int MEM = 100005; 
struct Splay { 
    static Splay nil, mem[MEM], *pmem; Splay *ch[2], *f; 
    int val, rev, size; 
    Splay () : val(-1), rev(0), size(0){ 
        f = ch[0] = ch[1] = &nil; 
        } 
    Splay (int _val) : val(_val), rev(0), size(1){ 
        f = ch[0] = ch[1] = &nil; 
        } 
    bool isr(){ 
        return f->ch[0] != this && f->ch[1] != this; 
        } 
    int dir(){ 
        return f->ch[0] == this ? 0 : 1; 
        } 
    void setCh(Splay *c, int d){ 
        ch[d] = c; 
        if (c != &nil) c->f = this; 
        pull(); 
        } 
    void push(){ 
        if (rev){ 
            swap(ch[0], ch[1]); 
            if (ch[0] != &nil) ch[0]->rev ^= 1; 
            if (ch[1] != &nil) ch[1]->rev ^= 1; 
            rev=0; 
            } 
        } 
    void pull(){ 
        size = ch[0]->size + ch[1]->size + 1; 
        if (ch[0] != &nil) ch[0]->f = this; 
        if (ch[1] != &nil) ch[1]->f = this; 
        } 
    } Splay::nil, Splay::mem[MEM], *Splay::pmem = Splay:: mem; 
Splay *nil = &Splay::nil; 
void rotate(Splay *x){ 
    Splay *p = x->f; 
    int d = x->dir(); 
    if (!p->isr()) p->f->setCh(x, p->dir()); 
    else x->f = p->f; 
    p->setCh(x->ch[!d], d); 
    x->setCh(p, !d); 
    p->pull(); x->pull();
    } 
vector<Splay*> splayVec; 
void splay(Splay *x){
    splayVec.clear(); 
    for (Splay *q=x;; q=q->f){ 
        splayVec.push_back(q); 
        if (q->isr()) break; 
        } 
    reverse(begin(splayVec), end(splayVec)); 
    for (auto it : splayVec) it->push(); 
    while (!x->isr()) { 
        if (x->f->isr()) rotate(x); 
        else if (x->dir()==x->f->dir()) rotate(x->f),rotate(x); 
        else rotate(x),rotate(x); 
        }
    } 
Splay* access(Splay *x){ 
    Splay *q = nil; 
    for (;x!=nil;x=x->f){ 
        splay(x); 
        x->setCh(q, 1); 
        q = x; 
        } 
    return q; 
    } 
void evert(Splay *x){ 
    access(x); 
    splay(x); 
    x->rev ^= 1; 
    x->push(); 
    x->pull(); 
    } 
void link(Splay *x, Splay *y){ 
    // evert(x); 
    access(x); 
    splay(x); 
    evert(y); 
    x->setCh(y, 1); 
    } 
void cut(Splay *x, Splay *y){ 
    // evert(x); 
    access(y); 
    splay(y); 
    y->push(); 
    y->ch[0] = y->ch[0]->f = nil; 
    } 
int N, Q; Splay *vt[MXN]; 
int ask(Splay *x, Splay *y){ 
    access(x); 
    access(y); 
    splay(x); 
    int res = x->f->val; 
    if (res == -1) res=x->val; 
    return res; 
    } 
int main(int argc, char** argv){ 
    scanf("%d%d", &N, &Q); 
    for (int i=1; i<=N; i++) 
        vt[i] = new (Splay::pmem++) Splay(i); 
    while (Q--) { 
        char cmd[105]; 
        int u, v; 
        scanf("%s", cmd); 
        if (cmd[1] == 'i') { 
            scanf("%d%d", &u, &v); 
            link(vt[v], vt[u]); 
            } 
        else if (cmd[0] == 'c') { 
            scanf("%d", &v); 
            cut(vt[1], vt[v]); 
            } 
        else { 
            scanf("%d%d", &u, &v); 
            int res=ask(vt[u], vt[v]); 
            printf("%d\n", res); 
            } 
        } 
    }

//SPFA 負環
bool loop(double k,int n){
    static int us[705];
    static double val[705];
    static bool iq[705];
    for(int i=0;i<=n;i++)
        us[i]=0,val[i]=INFINITY,iq[i]=false;
    queue<int>qu;
    qu.push(0);
    val[0]=0;
    iq[0]=true;
    while(!qu.empty()){
        int now=qu.front();
        qu.pop();
        iq[now]=false;
        for(par x:nod[now]){
            if(val[x.f]>val[now]+x.s+k){
                val[x.f]=val[now]+x.s+k;
                if(!iq[x.f]){
                    if(++us[x.f]>=n)return true;
                    iq[x.f]=true;
                    qu.push(x.f);
                    }
                }
            }
        }
    return false;
    }

//Fast Linear Recurrence
ll n,m,dp[N+N]; 
void pre_dp(){ 
    dp[0]= 1; 
    ll bdr = min(m+m,n); 
    for(ll i=1; i<=bdr; i++) 
        for(ll j=i-1; j>=max(0ll,i-m); j--) 
        dp[i]= add(dp[i],dp[j]); 
    } 
vector<ll> Mul(const vector<ll>& v1,const vector<ll>& v2){ 
    int sz1 = (int)v1.size(); 
    int sz2 = (int)v2.size(); 
    assert(sz1 == m and sz2 == m); 
    vector<ll> _v(m+m); 
    for(int i=0; i<m+m; i++) _v[i]= 0;
    // expand 
    for(int i=0; i<sz1; i++) 
        for(int j=0; j<sz2; j++) 
            _v[i+j+1]= add(_v[i+j+1],mul(v1[i],v2[j])); 
    // shrink 
    for(int i=0; i<m; i++) 
        for(int j=1; j<=m; j++) 
            _v[i + j]= add(_v[i + j],_v[i]); 
    for(int i=0; i<m; i++) 
        _v[i]= _v[i + m]; 
        _v.resize(m); 
        return _v;
    } 
vector<ll> I,A; 
ll solve(){ 
    pre_dp(); 
    if(n <= m+m)return dp[n]; 
    I.resize(m); 
    A.resize(m); 
    for(int i=0; i<m; i++) 
        I[i]=A[i]=1; 
    // dp[n]= /Sum_{i=0}^{m-1} A_i * dp[n - i - 1] 
    ll dlt = (n - m) / m; 
    ll rdlt = dlt * m; 
    while(dlt){ 
        if(dlt & 1ll) 
            I = Mul(I,A); 
        A = Mul(A,A); 
        dlt >>= 1; 
        } 
    ll ans = 0; 
    for(int i=0; i<m; i++) 
        ans = add(ans,mul(I[i],dp[n-i-1-rdlt])); 
    return ans; 
    }

//Miller Rabin
// n < 4,759,123,141 3 : 2, 7, 61 
// n < 1,122,004,669,633 4 : 2, 13, 23, 1662803 
// n < 3,474,749,660,383 6 : pirmes <= 13 
// n < 2^64 7 : 2, 325, 9375, 28178, 450775, 9780504, 1795265022 
// Make sure testing integer is in range [2, n−2] if you want to use magic. 
long long power(long long x,long long p,long long mod){ 
    long long s=1,m=x; while(p) { 
        if(p&1) s=mult(s,m,mod); 
        p>>=1; m=mult(m,m,mod); 
        } 
    return s; 
    } 
bool witness(long long a,long long n,long long u,int t) { 
    long long x=power(a,u,n); 
    for(int i=0;i<t;i++) { 
        long long nx=mult(x,x,n); 
        if(nx==1&&x!=1&&x!=n-1) 
            return 1; 
        x=nx; 
        } 
    return x!=1; 
    } 
bool miller_rabin(long long n,int s=100) { 
    // iterate s times of witness on n 
    // return 1 if prime, 0 otherwise 
    if(n<2) return 0; 
    if(!(n&1)) return n==2; 
    long long u=n-1; 
    int t=0; 
    // n-1 = u*2^t 
    while(!(u&1)) { 
        u>>=1; 
        t++; 
        } 
    while(s--) { 
        long long a=randll()%(n-1)+1; 
        if(witness(a,n,u,t)) 
            return 0; 
        } 
    return 1; 
    }
//Pollard Rho
// does not work when n is prime 
long long modit(long long x,long long mod) { 
    if(x>=mod) x-=mod; 
    //if(x<0) x+=mod; 
    return x; 
    } 
long long mult(long long x,long long y,long long mod) { 
    long long s=0,m=x%mod; 
    while(y) { 
        if(y&1) s=modit(s+m,mod); 
        y>>=1; 
        m=modit(m+m,mod); 
        } 
    return s; 
    } 
long long f(long long x,long long mod) { 
    return modit(mult(x,x,mod)+1,mod); 
    } 
long long pollard_rho(long long n) { 
    if(!(n&1)) return 2; 
    while (true) { 
        long long y=2, x=rand()%(n-1)+1, res=1; 
        for (int sz=2; res==1; sz*=2) { 
            for (int i=0; i<sz && res<=1; i++) { 
                x = f(x, n); 
                res = __gcd(abs(x-y), n); 
                } 
            y = x; 
            } 
        if (res!=0 && res!=n) return res;
        }
    }

//Pseudoinverse of Square matrix
Mat pinv(Mat m) { 
    Mat res = I; FZ(used); 
    for(int i=0; i<W; i++) { 
        int piv = -1; 
        for(int j=0; j<W; j++) { 
            if(used[j]) continue; 
            if(abs(m.v[j][i]) > EPS) { 
                piv = j; break; 
                } 
            } 
        if(piv == -1) continue; 
        used[i] = true; 
        swap(m.v[piv], m.v[i]); 
        swap(res.v[piv], res.v[i]); 
        ld rat = m.v[i][i]; 
        for(int j=0; j<W; j++) { 
            m.v[i][j] /= rat; res.v[i][j] /= rat; 
            } 
        for(int j=0; j<W; j++) { 
            if(j == i) continue; 
            rat = m.v[j][i]; 
            for(int k=0; k<W; k++) { 
                m.v[j][k] -= rat * m.v[i][k]; 
                res.v[j][k] -= rat * res.v[i][k]; 
                } 
            } 
        } 
    for(int i=0; i<W; i++) { 
        if(used[i]) continue; 
        for(int j=0; j<W; j++) 
        res.v[i][j] = 0; 
        } 
    return res; 
    }

//kd-tree
#ifndef SUNMOON_DYNEMIC_KD_TREE
#define SUNMOON_DYNEMIC_KD_TREE
template<typename T,size_t kd>//kd表示有幾個維度 
class kd_tree{
	public:
		struct point{
			T d[kd];
			inline T dist(const point &x)const{
				T ret=0;
				for(size_t i=0;i<kd;++i)ret+=std::abs(d[i]-x.d[i]);
				return ret;
			}
			inline bool operator==(const point &p){
				for(size_t i=0;i<kd;++i){
					if(d[i]!=p.d[i])return 0;
				}
				return 1;
			}
			inline bool operator<(const point &b)const{
				return d[0]<b.d[0];
			}
		};
	private:
		struct node{
			node *l,*r;
			point pid;
			int s;
			node(const point &p):l(0),r(0),pid(p),s(1){}
			inline void up(){
				s=(l?l->s:0)+1+(r?r->s:0);
			}
		}*root;
		const double alpha,loga;
		const T INF;//記得要給INF，表示極大值 
		int maxn;
		struct __cmp{
			int sort_id;
			inline bool operator()(const node*x,const node*y)const{
				return operator()(x->pid,y->pid);
			}
			inline bool operator()(const point &x,const point &y)const{
				if(x.d[sort_id]!=y.d[sort_id])
					return x.d[sort_id]<y.d[sort_id];
				for(size_t i=0;i<kd;++i){
					if(x.d[i]!=y.d[i])return x.d[i]<y.d[i];
				}
				return 0;
			}
		}cmp;
		void clear(node *o){
			if(!o)return;
			clear(o->l);
			clear(o->r);
			delete o;
		}
		inline int size(node *o){
			return o?o->s:0;
		}
		std::vector<node*> A;
		node* build(int k,int l,int r){
			if(l>r)return 0;
			if(k==kd)k=0;
			int mid=(l+r)/2;
			cmp.sort_id=k;
			std::nth_element(A.begin()+l,A.begin()+mid,A.begin()+r+1,cmp);
			node *ret=A[mid];
			ret->l=build(k+1,l,mid-1);
			ret->r=build(k+1,mid+1,r);
			ret->up();
			return ret;
		}
		inline bool isbad(node*o){
			return size(o->l)>alpha*o->s||size(o->r)>alpha*o->s;
		}
		void flatten(node *u,typename std::vector<node*>::iterator &it){
			if(!u)return;
			flatten(u->l,it);
			*it=u;
			flatten(u->r,++it);
		}
		inline void rebuild(node*&u,int k){
			if((int)A.size()<u->s)A.resize(u->s);
			typename std::vector<node*>::iterator it=A.begin();
			flatten(u,it);
			u=build(k,0,u->s-1);
		}
		bool insert(node*&u,int k,const point &x,int dep){
			if(!u){
				u=new node(x);
				return dep<=0;
			}
			++u->s;
			cmp.sort_id=k;
			if(insert(cmp(x,u->pid)?u->l:u->r,(k+1)%kd,x,dep-1)){
				if(!isbad(u))return 1;
				rebuild(u,k);
			}
			return 0;
		}
		node *findmin(node*o,int k){
			if(!o)return 0; 
			if(cmp.sort_id==k)return o->l?findmin(o->l,(k+1)%kd):o;
			node *l=findmin(o->l,(k+1)%kd);
			node *r=findmin(o->r,(k+1)%kd);
			if(l&&!r)return cmp(l,o)?l:o;
			if(!l&&r)return cmp(r,o)?r:o;
			if(!l&&!r)return o;
			if(cmp(l,r))return cmp(l,o)?l:o;
			return cmp(r,o)?r:o;
		}
		bool erase(node *&u,int k,const point &x){
			if(!u)return 0;
			if(u->pid==x){
				if(u->r);
				else if(u->l){
					u->r=u->l;
					u->l=0;
				}else{
					delete u;
					u=0;
					return 1;
				}
				--u->s;
				cmp.sort_id=k;
				u->pid=findmin(u->r,(k+1)%kd)->pid;
				return erase(u->r,(k+1)%kd,u->pid);
			}
			cmp.sort_id=k;
			if(erase(cmp(x,u->pid)?u->l:u->r,(k+1)%kd,x)){
				--u->s;return 1;
			}else return 0;
		}
		inline T heuristic(const T h[])const{
			T ret=0;
			for(size_t i=0;i<kd;++i)ret+=h[i];
			return ret;
		}
		int qM;
		std::priority_queue<std::pair<T,point > >pQ;
		void nearest(node *u,int k,const point &x,T *h,T &mndist){
			if(u==0||heuristic(h)>=mndist)return;
			T dist=u->pid.dist(x),old=h[k];
			/*mndist=std::min(mndist,dist);*/
			if(dist<mndist){
				pQ.push(std::make_pair(dist,u->pid));
				if((int)pQ.size()==qM+1){
					mndist=pQ.top().first,pQ.pop();
				}
			}
			if(x.d[k]<u->pid.d[k]){
				nearest(u->l,(k+1)%kd,x,h,mndist);
				h[k]=std::abs(x.d[k]-u->pid.d[k]);
				nearest(u->r,(k+1)%kd,x,h,mndist);
			}else{
				nearest(u->r,(k+1)%kd,x,h,mndist);
				h[k]=std::abs(x.d[k]-u->pid.d[k]);
				nearest(u->l,(k+1)%kd,x,h,mndist);
			}
			h[k]=old;
		}
		std::vector<point>in_range;
		void range(node *u,int k,const point&mi,const point&ma){
			if(!u)return;
			bool is=1;
			for(int i=0;i<kd;++i)
				if(u->pid.d[i]<mi.d[i]||ma.d[i]<u->pid.d[i]){
					is=0;break;
				}
			if(is)in_range.push_back(u->pid);
			if(mi.d[k]<=u->pid.d[k])range(u->l,(k+1)%kd,mi,ma);
			if(ma.d[k]>=u->pid.d[k])range(u->r,(k+1)%kd,mi,ma);
		}
	public:
		kd_tree(const T &INF,double a=0.75):root(0),alpha(a),loga(log2(1.0/a)),INF(INF),maxn(1){}
		inline void clear(){
			clear(root),root=0,maxn=1;
		}
		inline void build(int n,const point *p){
			clear(root),A.resize(maxn=n);
			for(int i=0;i<n;++i)A[i]=new node(p[i]);
			root=build(0,0,n-1);
		}
		inline void insert(const point &x){
			insert(root,0,x,std::__lg(size(root))/loga);
			if(root->s>maxn)maxn=root->s;
		}
		inline bool erase(const point &p){
			bool d=erase(root,0,p);
			if(root&&root->s<alpha*maxn)rebuild();
			return d;
		}
		inline void rebuild(){
			if(root)rebuild(root,0);
			maxn=root->s;
		}
		inline T nearest(const point &x,int k){
			qM=k;
			T mndist=INF,h[kd]={};
			nearest(root,0,x,h,mndist);
			mndist=pQ.top().first;
			pQ=std::priority_queue<std::pair<T,point > >();
			return mndist;/*回傳離x第k近的點的距離*/ 
		}
		inline const std::vector<point> &range(const point&mi,const point&ma){
			in_range.clear();
			range(root,0,mi,ma);
			return in_range;/*回傳介於mi到ma之間的點vector*/ 
		}
		inline int size(){return root?root->s:0;}
};
#endif

//Aho-Corasick Algorithm
struct ACautomata{ 
    struct Node{ 
        int cnt,dp; 
        Node *go[26], *fail; 
        Node (){ 
            cnt = 0; dp = -1; fail = 0;
            memset(go,0,sizeof(go)); 
            } 
        }; 
    Node *root, pool[1048576]; 
    int nMem; 
    Node* new_Node(){ 
        pool[nMem] = Node(); 
        return &pool[nMem++]; 
        } 
    void init(){ 
        nMem = 0; 
        root = new_Node();
        } 
    void add(const string &str){ 
        insert(root,str,0); 
        } 
    void insert(Node *cur, const string &str, int pos){ 
        if (pos >= (int)str.size()){ 
            cur->cnt++;
            return; 
            } 
        int c = str[pos]-'a'; 
        if (cur->go[c] == 0)
            cur->go[c] = new_Node(); 
        insert(cur->go[c],str,pos+1); 
        } 
    void make_fail(){ 
        queue<Node*> que; que.push(root); 
        while (!que.empty()){ 
            Node* fr=que.front(); que.pop(); 
            for (int i=0; i<26; i++){ 
                if (fr->go[i]){ 
                    Node *ptr = fr->fail; 
                    while (ptr && !ptr->go[i]) ptr = ptr->fail; 
                    if (!ptr) fr->go[i]->fail = root; 
                    else fr->go[i]->fail = ptr->go[i]; 
                    que.push(fr->go[i]); 
                    } 
                } 
            } 
        } 
    };

//莫隊算法
#define MAXQ 100000
struct Q{
	int l,r,i,block;
	inline bool operator<(const Q &b)const{
		return block==b.block?r<b.r:block<b.block;
    	}
    }q[MAXQ+5];
int main(){
    //input > q;
    lim=1+(int)sqrt(n);
    for(int i=0;i<m;++i){
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].block=q[i].l/lim;
        q[i].i=i;
        }
    sort(q,q+m);
    for(int i=0,L=1,R=0;i<m;++i){/*這是閉區間的寫法*/
        while(R<q[i].r)add(s[++R]);
        while(R>q[i].r)sub(s[R--]);
        while(L>q[i].l)add(s[--L]);
        while(L<q[i].l)sub(s[L++]);
        ans[q[i].i]=cur_ans;
        }
    for(int i=0;i<m;++i)printf("%d\n",ans[i]);
    }
    
//NTT2
// 多项式乘法 系数对MOD=1000000007取模， 常数巨大，慎用
// 只要选的K个素数乘积大于MOD*MOD*N,理论上MOD可以任取。
#define MOD 1000000007
#define K 3
const int m[K] = {1004535809, 998244353, 104857601};
#define G 3
int qpow(int x, int k, int P) {
	int ret = 1;
	while(k) {
		if(k & 1) ret = 1LL * ret * x % P;
		k >>= 1;
		x = 1LL * x * x % P;
	    }
	return ret;
    }
struct _NTT {
	int wn[25], P;
	void init(int _P) {
		P = _P;
		for(int i = 1; i <= 21; ++i) {      
			int t = 1 << i;      
			wn[i] = qpow(G, (P - 1) / t, P);      
		    }
        }
	void change(int *y, int len) {
		for(int i = 1, j = len / 2; i < len - 1; ++i) {      
			if(i < j) swap(y[i], y[j]);      
			int k = len / 2;      
			while(j >= k) {      
				j -= k;      
				k /= 2;      
    			}      
			j += k;      
	    	} 
	    }
	void NTT(int *y, int len, int on) {
		change(y, len);      
		int id = 0;
		for(int h = 2; h <= len; h <<= 1) {      
			++id;      
			for(int j = 0; j < len; j += h) {      
				int w = 1;      
				for(int k = j; k < j + h / 2; ++k) {      
					int u = y[k];      
					int t = 1LL * y[k+h/2] * w % P;     
					y[k] = u + t;      
					if(y[k] >= P) y[k] -= P;      
					y[k+h/2] = u - t + P;      
					if(y[k+h/2] >= P) y[k+h/2] -= P;  
					w = 1LL * w * wn[id] % P;
				    }      
			    }      
		    }      
		if(on == -1) {      
			for(int i = 1; i < len / 2; ++i) swap(y[i], y[len-i]);      
			int inv = qpow(len, P - 2, P);      
			for(int i = 0; i < len; ++i)   
				y[i] = 1LL * y[i] * inv % P;
		    }      
	    }
	void mul(int A[], int B[], int len) {
		NTT(A, len, 1);
		NTT(B, len, 1);
		for(int i = 0; i < len; ++i) A[i] = 1LL * A[i] * B[i] % P;
		NTT(A, len, -1);
	    }
    }ntt[K];
int tmp[N][K], t1[N], t2[N];
int r[K][K];
int CRT(int a[]) {
	int x[K];
	for(int i = 0; i < K; ++i) {
		x[i] = a[i];
		for(int j = 0; j < i; ++j) {
			int t = (x[i] - x[j]) % m[i];
			if(t < 0) t += m[i];
			x[i] = 1LL * t * r[j][i] % m[i];
		    }
	    }
	int mul = 1, ret = x[0] % MOD;
	for(int i = 1; i < K; ++i) {
		mul = 1LL * mul * m[i-1] % MOD;
		ret += 1LL * x[i] * mul % MOD;
		if(ret >= MOD) ret -= MOD;
	    }
	return ret;
    }
void mul(int A[], int B[], int len) {
	for(int id = 0; id < K; ++id) {
		for(int i = 0; i < len; ++i) {
			t1[i] = A[i];
			t2[i] = B[i];
		    }
		ntt[id].mul(t1, t2, len);
		for(int i = 0; i < len; ++i) 
			tmp[i][id] = t1[i];
	    }
	for(int i = 0; i < len; ++i) {
		A[i] = CRT(tmp[i]);

	    }
    }

void init() {
	for(int i = 0; i < K; ++i) {
		for(int j = 0; j < i; ++j) {
			r[j][i] = qpow(m[j], m[i] - 2, m[i]);
		    }
	    }
	for(int i = 0; i < K; ++i) {
		ntt[i].init(m[i]);
	    }
    }

//Eular
#define maxn 10000000
int euler[maxn+5];
bool is_prime[maxn+5];
void init_euler(){
	is_prime[1]=1;//一不是質數
	for(int i=1;i<=maxn;i++)euler[i]=i;
	for(int i=2;i<=maxn;i++){
		if(!is_prime[i]){//是質數
			euler[i]--;
			for(int j=i<<1;j<=maxn;j+=i){
				is_prime[j]=1;
				euler[j]=euler[j]/i*(i-1);
			    }
		    }
	    }
    }
int Euler(int n){
	int ans=n;
	for(int i=2;i*i<=n;i++){
		if(n%i==0){
			ans=ans/i*(i-1);
			while(n%i==0)n/=i;
	    	}
	    }
	if(n>1)ans=ans/n*(n-1);
	return ans;
    }

//Suffix Automaton 後綴自動機 
#ifndef SUFFIX_AUTOMATON
#define SUFFIX_AUTOMATON
#include<vector>
template<char L='a',char R='z'>
struct suffix_automaton{
	struct node{
		int ch[R-L+1],fa,len;
		node(int l=0):fa(0),len(l){
			for(int i=0;i<=R-L;++i)ch[i]=0;
		}
	};
	std::vector<node >S;
	int tail,u,v,np,vp;
	suffix_automaton():S(2),tail(1){S[0].fa=0;}
	inline void add(int c){
		c-=L;
		u=tail;
		S.push_back(node(S[u].len+1));
		tail=np=S.size()-1;
		for(;u&&!S[u].ch[c];u=S[u].fa)S[u].ch[c]=np;
		if(!u)S[np].fa=1;
		else{
			v=S[u].ch[c];
			if(S[v].len==S[u].len+1)S[np].fa=v;
			else{
				S.push_back(S[v]);
				vp=S.size()-1;
				S[vp].len=S[u].len+1;
				S[v].fa=S[np].fa=vp;
				for(;u&&S[u].ch[c]==v;u=S[u].fa)S[u].ch[c]=vp;
			}
		}
	}
	inline int size(){return S.size()-2;}
};
#endif

//平面最小生成樹
#define N 50010
int n;
int x[N], y[N];
struct Node {
    int x, y, lab;
    Node(int _x = 0, int _y = 0, int _lab = 0):x(_x),y(_y),lab(_lab){}
    bool operator < (const Node &B) const {
        return (x > B.x || (x == B.x && y > B.y)); 
        }
    }S[N];
struct Edge {
    int from, to, len;
    Edge(int _from = 0, int _to = 0, int _len = 0):from(_from),to(_to),len(_len){}
    bool operator < (const Edge &B) const {
        return len < B.len;
        }
    }E[N << 2];
int top;
int sa[N], rank[N], change[N];
inline bool cmp(const int &a, const int &b) {
    return S[a].y - S[a].x > S[b].y - S[b].x;
}
int A[N];
int ask(int p) {
    int res = 0;
    for(; p; p -= p & -p)
        if (S[change[res]].x + S[change[res]].y > S[change[A[p]]].x + S[change[A[p]]].y)
            res = A[p];
    return res;
    }
void modify(int p, int ins) {
    for(; p <= n; p += p & -p)
        if (S[change[ins]].x + S[change[ins]].y < S[change[A[p]]].x + S[change[A[p]]].y)
            A[p] = ins;
    }
void AddEdge() {
    register int i, j, k;
    for(i = 1; i <= n; ++i)
        sa[i] = i;
    sort(sa + 1, sa + n + 1, cmp);
    int id = 0;
    for(i = 1; i <= n; ) {
        for(j = i; S[sa[j]].y - S[sa[j]].x == S[sa[j + 1]].y - S[sa[j + 1]].x && j < n; ++j);
        ++id;
        for(k = i; k <= j; ++k)
            rank[sa[k]] = id;
        i = j + 1;
        }
    sort(S + 1, S + n + 1);
    for(i = 1; i <= n; ++i)
        change[S[i].lab] = i;
    memset(A, 0, sizeof(A));
    for(i = 1; i <= n; ++i) {
        int get = ask(rank[S[i].lab]);
        if (get != 0)
            E[++top] = Edge(S[i].lab, get, _abs(x[S[i].lab] - x[get]) + _abs(y[S[i].lab] - y[get]));
        modify(rank[S[i].lab], S[i].lab);
        }
    }
int root[N];
void reset() {
    for(int i = 1; i <= n; ++i)
        root[i] = i;
    }
int find(int x) {
    int q = x, tmpq;
    for(; x != root[x]; x = root[x]);
    for(; q != x; q = tmpq)
        tmpq = root[q], root[q] = x;
    return x;
    }
long long Kruskal() {
    sort(E + 1, E + top + 1);
    reset();
    register int i;
    int ra, rb, intree = 0;
    long long res = 0;
    for(i = 1; i <= top; ++i) {
        ra = find(E[i].from);
        rb = find(E[i].to);
        if (ra != rb) {
            root[ra] = rb;
            res += E[i].len;
            if (++intree == n - 1)
                return res;
            }
        }
    return -1;
    }
int main() {
    n = getint();
    register int i;
    for(i = 1; i <= n; ++i)
        x[i] = getint(), y[i] = getint();
    S[0].x = S[0].y = 0x3f3f3f3f;
    for(i = 1; i <= n; ++i)
        S[i] = Node(x[i], y[i], i);
    AddEdge();
    for(i = 1; i <= n; ++i)
        S[i] = Node(y[i], x[i], i);
    AddEdge();
    for(i = 1; i <= n; ++i)
        S[i] = Node(-y[i], x[i], i);
    AddEdge();
    for(i = 1; i <= n; ++i)
        S[i] = Node(x[i], -y[i], i);
    AddEdge();
    printf("%lld", Kruskal());   
    return 0;
    }
    
    //線性規劃
    const int MAXN = 111;
const int MAXM = 111;
const double eps = 1E-10;
double a[MAXN][MAXM], b[MAXN], c[MAXM], d[MAXN][MAXM];
double x[MAXM];
int ix[MAXN + MAXM]; // !!! array all indexed from 0
// max{cx} subject to {Ax<=b,x>=0}
// n: constraints, m: vars !!!
// x[] is the optimal solution vector
// usage : 
// value = simplex(a, b, c, N, M);
double simplex(double a[MAXN][MAXM], double b[MAXN],
               double c[MAXM], int n, int m){
  ++m;
  int r = n, s = m - 1;
  memset(d, 0, sizeof(d));
  for (int i = 0; i < n + m; ++i) ix[i] = i;
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m - 1; ++j) d[i][j] = -a[i][j];
    d[i][m - 1] = 1;
    d[i][m] = b[i];
    if (d[r][m] > d[i][m]) r = i;
  }
  for (int j = 0; j < m - 1; ++j) d[n][j] = c[j];
  d[n + 1][m - 1] = -1;
  for (double dd;; ) {
    if (r < n) {
      int t = ix[s]; ix[s] = ix[r + m]; ix[r + m] = t;
      d[r][s] = 1.0 / d[r][s];
      for (int j = 0; j <= m; ++j)
        if (j != s) d[r][j] *= -d[r][s];
      for (int i = 0; i <= n + 1; ++i) if (i != r) {
        for (int j = 0; j <= m; ++j) if (j != s)
          d[i][j] += d[r][j] * d[i][s];
        d[i][s] *= d[r][s];
      }
    }
    r = -1; s = -1;
    for (int j = 0; j < m; ++j)
      if (s < 0 || ix[s] > ix[j]) {
        if (d[n + 1][j] > eps ||
            (d[n + 1][j] > -eps && d[n][j] > eps))
          s = j;
      }
    if (s < 0) break;
    for (int i = 0; i < n; ++i) if (d[i][s] < -eps) {
      if (r < 0 ||
          (dd = d[r][m] / d[r][s] - d[i][m] / d[i][s]) < -eps ||
          (dd < eps && ix[r + m] > ix[i + m]))
        r = i;
    }
    if (r < 0) return -1; // not bounded
  }
  if (d[n + 1][m] < -eps) return -1; // not executable
  double ans = 0;
  for(int i=0; i<m; i++) x[i] = 0;
  for (int i = m; i < n + m; ++i) { // the missing enumerated x[i] = 0
    if (ix[i] < m - 1){
      ans += d[i - m][m] * c[ix[i]];
      x[ix[i]] = d[i-m][m];
    }
  }
  return ans; 
}

// undirected graph minimum cut 
typedef vector<int> VI;
typedef vector<VI> VVI;

const int INF = 1000000000;

pair<int, VI> GetMinCut(VVI &weights) {
  int N = weights.size();
  VI used(N), cut, best_cut;
  int best_weight = -1;

  for (int phase = N-1; phase >= 0; phase--) {
    VI w = weights[0];
    VI added = used;
    int prev, last = 0;
    for (int i = 0; i < phase; i++) {
      prev = last;
      last = -1;
      for (int j = 1; j < N; j++)
	if (!added[j] && (last == -1 || w[j] > w[last])) last = j;
      if (i == phase-1) {
	for (int j = 0; j < N; j++) weights[prev][j] += weights[last][j];
	for (int j = 0; j < N; j++) weights[j][prev] = weights[prev][j];
	used[last] = true;
	cut.push_back(last);
	if (best_weight == -1 || w[last] < best_weight) {
	  best_cut = cut;
	  best_weight = w[last];
	}
      } else {
	for (int j = 0; j < N; j++)
	  w[j] += weights[last][j];
	added[last] = true;
      }
    }
  }
  return make_pair(best_weight, best_cut);
}

// SuffixAutomaton
#include<bits/stdc++.h>
using namespace std;
#define MAXNODE 2000005
#define SIGMA 26
struct node{
    node *fail,*ch[SIGMA];
    int len,cnt,vis;
    node() {fail=0;len=cnt=vis=0;memset(ch,0,sizeof ch);}
}mem[MAXNODE], *root, *last;

int str_cnt;

struct SuffixAutomaton{
    int size;
    inline int idx(char c){return c-'a';}
    inline void init(){
        size = 0;
        root = last = &mem[0];
    }
    // main SAM
    inline void add(char c){
        c = idx(c);
        node *pre = last;
        node *now = &mem[++size];
        now->len = pre->len+1;
        while(pre && !pre->ch[c]){
            pre->ch[c] = now;
            pre = pre->fail;
        }
        if(!pre) now->fail = root;
        else{
            node *q = pre->ch[c];
            if(q->len == pre->len+1) now->fail = q;
            else
            {
                node *nq = &mem[++size];
                nq->len = pre->len+1;
                memcpy(nq->ch, q->ch, sizeof(q->ch));
                nq->fail = q->fail;
                q->fail = now->fail = nq;
                while(pre && pre->ch[c] == q){
                    pre->ch[c] = nq;
                    pre=pre->fail;
                }
            }
        }
        last = now;
    }
    // solve problem
    int C[MAXNODE], ord[MAXNODE];
    void build_cnt(char* s,int n){
        for(int i = 0; i <= size; i++) C[mem[i].len]++;
        for(int i = 1; i <= size; i++) C[i] += C[i-1];
        for(int i = 0; i <= size; i++) ord[--C[mem[i].len]] = i;
        node* now = root;
        for(int i = 0; i < n; i++){
            int c = idx(s[i]);
            now = now->ch[c];
            now->cnt = 1;
        }
        for(int i = size; i >= 0; i--){
            now = &mem[ord[i]];
            if(now->fail) now->fail->cnt += now->cnt;
        }
    }

    int solve(char* s){
        str_cnt++;
        int n = strlen(s), cnt = 0, ans = 0;
        node* now = root;
        for(int i = 0; i < n-1; i++){
            int c = idx(s[i]);
            if(now->ch[c]) cnt++, now = now->ch[c];
            else{
                while(now && !now->ch[c]) now = now->fail;
                if(!now) cnt=0, now=root;
                else cnt = now->len+1, now = now->ch[c];
            }
            while(cnt >= n/2 && now->fail && now->fail->len >= n/2){
                cnt = now->fail->len;
                now = now->fail;
            }
            if(cnt >= n/2 && now->vis != str_cnt){
                ans += now->cnt;
                now->vis = str_cnt;
            }
        }
        return ans;
    }
}SAM;

char s[MAXNODE];
int main(){
    SAM.init();
    scanf("%s",s);
    int n=strlen(s);
    for(int i=0;i<n;i++){
        SAM.add(s[i]);
    }
    SAM.build_cnt(s,n);
    int t;
    scanf("%d",&t);
    while(t--){
        scanf("%s",s);
        n=strlen(s);
        for(int i=n;i<n*2;i++) s[i]=s[i-n];
        s[n*2]=0;
        printf("%d\n",SAM.solve(s));
    }
}

//Templated Treap
#define temT template<typename T>
temT struct nna{static const nna obj;};
temT nna<T> const nna<T>::obj={};
temT struct node;
temT using ptr=node<T>*;
temT struct node{
    typedef node<T>* ptr;
    static node<T> nil_obj;
    static ptr nil;
    ptr l,r,fa;
    T v;
    unsigned int sz;
    node(T _v,ptr _fa=nil){v=_v,sz=1,l=r=nil,fa=_fa;}
    node(nna<T>){v=0,sz=0,fa=l=r=nil;}
    void push(){fa=nil;}
    void pull(){sz=l->sz+r->sz+1;if(l!=nil)l->fa=this;if(r!=nil)r->fa=this;}
    ptr top(){
        ptr now=this;
        if(fa)now=fa->top();
        return now;
        }
    ptr left(){
        if(l)return l->left();
        return this;
        }
    ptr right(){
        if(r)return r->right();
        return this;
        }
    ptr next(){
        if(r)return r->left();
        ptr now=this;
        while(now->fa)
            if(now->fa->l==now)return now->fa;
            else now=now->fa;
        return nil;
        }
    ptr pre(){
        if(l)return l->right();
        ptr now=this;
        while(now->fa)
            if(now->fa->r==now)return now->fa;
            else now=now->fa;
        return nil;
        }
    };
temT node<T> node<T>::nil_obj(nna<T>::obj);
temT ptr<T> node<T>::nil=&node<T>::nil_obj;
temT struct treap{
    typedef node<T>* ptr;
    typedef node<T> node;
    ptr &nil=node::nil;
    ptr root;
    treap(){root=nil;}
    ptr merge(ptr a,ptr b){
        static unsigned int S=rand();
        if(a==nil)return b;
        if(b==nil)return a;
        if((S++)%(a->sz+b->sz)<a->sz){a->push(),a->r=merge(a->r,b),a->pull();return a;}
        else{b->push(),b->l=merge(a,b->l),b->pull();return b;}
        }
    void split(ptr now,T k,ptr &a,ptr &b){
        if(now==nil)a=b=nil;
        else if(now->v<k)
            a=now,a->push(),split(now->r,k,a->r,b),a->pull();
        else
            b=now,b->push(),split(now->l,k,a,b->l),b->pull();
        }
    void split_kth(ptr now,unsigned int k,ptr &a,ptr &b){
        if(now==nil)a=b=nil;
        else if(now->l->sz<k)
            a=now,a->push(),split_kth(now->r,k-now->l->sz,a->r,b),a->pull();
        else
            b=now,b->push(),split_kth(now->l,k,a,b->l),b->pull();
        }
    void insert(T k){
        ptr a=nil,b=nil;
        split(root,k,a,b);
        root=merge(merge(a,new node(k)),b);
        }
    void erase(T k){
        ptr a=nil,b=nil,c=nil,d=nil;
        split(root,k,a,b);
        split_kth(b,1,c,d);
        if(c!=nil)
            delete c;
        root=merge(a,d);
        }
    void push_back(T k){
        root=merge(root,new node(k));
        }
    void pop_back(){
        ptr a=nil,b=nil;
        if(root->sz)return;
        split_kth(root,root->sz-1,a,b);
        delete b;
        root=a;
        }
    ptr kth(ptr rot,unsigned int k){//0base
        if(k<rot->l->sz)return kth(rot->l,k);
        if(k==rot->l->sz)return rot;
        return kth(rot->r,k-rot->l->sz-1);
        }
    node& operator[](unsigned int k){
        if(k>=root->sz)return *nil;
        return *kth(root,k);
        }
    ptr lower_bound(T k){
        ptr now=root,pri=nil;
        while(now!=nil)
            if(k<=now->v)pri=now,now=now->l;
            else now=now->r;
        return pri;
        }
    ptr upper_bound(T k){
        ptr now=root,pri=nil;
        while(now!=nil)
            if(k<now->v)pri=now,now=now->r;
            else now=now->l;
        return pri;
        }
    };